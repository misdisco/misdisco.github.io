

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/YoRHa.ico">
  <link rel="icon" href="/img/YoRHa.ico">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="吕书科">
  <meta name="keywords" content="">
  
    <meta name="description" content="一个很好的在线运行java的环境 https:&#x2F;&#x2F;www.bejson.com&#x2F;runcode&#x2F;java&#x2F; 一、java基础知识1、DOS和Java特性1、window中常见的Dos命令输入cmd  mkdir 创建目录 cls 清除屏幕 exit 退出当前Dos命令窗口 dir 列出当前目录下所有的子文件&#x2F;子目录 cd 命令*cd命令表示：change directory【改变目录】*">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA基础知识笔记">
<meta property="og:url" content="https://aotomata.me/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="Automata">
<meta property="og:description" content="一个很好的在线运行java的环境 https:&#x2F;&#x2F;www.bejson.com&#x2F;runcode&#x2F;java&#x2F; 一、java基础知识1、DOS和Java特性1、window中常见的Dos命令输入cmd  mkdir 创建目录 cls 清除屏幕 exit 退出当前Dos命令窗口 dir 列出当前目录下所有的子文件&#x2F;子目录 cd 命令*cd命令表示：change directory【改变目录】*">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://aotomata.me/img/java.png">
<meta property="article:published_time" content="2020-04-18T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-13T14:51:17.363Z">
<meta property="article:author" content="吕书科">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="基础">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://aotomata.me/img/java.png">
  
  
  
  <title>JAVA基础知识笔记 - Automata</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"aotomata.me","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Automata</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/java.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JAVA基础知识笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-04-19 00:00" pubdate>
          2020年4月19日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          41k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          346 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">JAVA基础知识笔记</h1>
            
            
              <div class="markdown-body">
                
                <p>一个很好的在线运行java的环境</p>
<p><a target="_blank" rel="noopener" href="https://www.bejson.com/runcode/java/">https://www.bejson.com/runcode/java/</a></p>
<h1 id="一、java基础知识"><a href="#一、java基础知识" class="headerlink" title="一、java基础知识"></a>一、java基础知识</h1><h2 id="1、DOS和Java特性"><a href="#1、DOS和Java特性" class="headerlink" title="1、DOS和Java特性"></a>1、DOS和Java特性</h2><h3 id="1、window中常见的Dos命令"><a href="#1、window中常见的Dos命令" class="headerlink" title="1、window中常见的Dos命令"></a>1、window中常见的Dos命令</h3><p>输入cmd</p>
<ul>
<li>mkdir 创建目录</li>
<li>cls 清除屏幕</li>
<li>exit 退出当前Dos命令窗口</li>
<li>dir 列出当前目录下所有的子文件&#x2F;子目录</li>
<li>cd 命令<br>*cd命令表示：change directory【改变目录】<br>*使用方法：cd 目录的路径</li>
<li>cd… 回到上级目录</li>
<li>cd&#x2F; 回到跟目录</li>
<li>怎么切换盘符？<br>c:回车<br>d:回车</li>
<li>del 删除一个或多个文件</li>
<li>ipconfig 查看本机IP地址</li>
<li>ping IP地址 或 ping 域名：查看计算机是否可以正常通信</li>
</ul>
<h3 id="2、文件扩展名必须要以-java结尾的扩展名"><a href="#2、文件扩展名必须要以-java结尾的扩展名" class="headerlink" title="2、文件扩展名必须要以 .java结尾的扩展名"></a>2、文件扩展名必须要以 .java结尾的扩展名</h3><h3 id="3、Java语言发展史"><a href="#3、Java语言发展史" class="headerlink" title="3、Java语言发展史"></a>3、Java语言发展史</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java语言诞生于1995年。</span><br><span class="hljs-keyword"></span>-什么是<span class="hljs-keyword">JDK？</span><br><span class="hljs-keyword"></span>	<span class="hljs-keyword">Java开发工具包</span><br><span class="hljs-keyword"></span>	做<span class="hljs-keyword">Java开发必须安装的一个工具包，可从官网下载。</span><br><span class="hljs-keyword"></span>	*<span class="hljs-keyword">Java目前包括三大块：</span><br><span class="hljs-keyword"></span>	-<span class="hljs-keyword">JavaSE（Java标准版）</span><br><span class="hljs-keyword"></span>	-<span class="hljs-keyword">JavaEE（Java企业版）</span><br><span class="hljs-keyword"></span>	-<span class="hljs-keyword">JavaME（Java微型版）</span><br><span class="hljs-keyword"></span>	其中<span class="hljs-keyword">JavaEE是基础，主攻方向是JavaEE方向。</span><br></code></pre></td></tr></table></figure>

<h3 id="4、Java语言特性【开源、免费、纯面向对象、跨平台】"><a href="#4、Java语言特性【开源、免费、纯面向对象、跨平台】" class="headerlink" title="4、Java语言特性【开源、免费、纯面向对象、跨平台】"></a>4、Java语言特性【开源、免费、纯面向对象、跨平台】</h3><p><strong>简单性:</strong> 相对而言，例如Java中不在支持多继承，C++设计支持多继承的，多继承比较复杂。<br>C++中有指针，Java中屏蔽了指针的概念。所以Java是简单的。<br>Java语言的底层是C++实现的，不是c语言。</p>
<p><strong>面向对象性:</strong> Java是纯面向对象的，更符合人的思维模式，更容易理解。</p>
<p><em><strong>什么是面向对象？</strong></em></p>
<p><strong>封装</strong>：封装把一个对象的属性私有化、同时提供一些可以被外界访问的属性的方法。<br><strong>继承</strong>：<br>java是多单继承的，<br>子类拥有父类非private的属性和方法<br>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展<br>子类可以用自己的方式实现父类的方法<br><strong>多态</strong>：父类的引用指向子类</p>
<p><strong>可移植性:</strong><br>什么是可移植性？（跨平台性）</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Java程序可以做到一次编译，到处运行。也就是说Java程序可以在windows操作系统上运行，不做任何修改，同样的Java可以直接放到Linux操作系统上运行，这个被称为java程序的可移植性，或者叫做跨平台性。windows操作系统内核和Linux操作系统的内核肯定不同，他们这两个操作系统执行指令的方式也是不一样的。</span><br><span class="hljs-keyword"></span>结论： 显然<span class="hljs-keyword">Java程序不能直接和操作系统打交道。因为Java程序只有一份，操作系统执行原理都不同。</span><br><span class="hljs-keyword"></span><br>SUN团队让<span class="hljs-keyword">Java程序运行在一台虚拟的计算机当中，这个虚拟计算机叫做Java虚拟机，简称JVM。Java虚拟机再和底层的操作系统打交道。</span><br></code></pre></td></tr></table></figure>

<p><strong>多线程性</strong><br><strong>健壮性:</strong> 和自动垃圾回收机制有关，自动垃圾回收机制简称GC机制。<br>Java语言运行过程中产生的垃圾是自动回收的，不需要程序员关心。<br><strong>安全性</strong></p>
<h2 id="2、Java——集成开发环境"><a href="#2、Java——集成开发环境" class="headerlink" title="2、Java——集成开发环境"></a>2、Java——集成开发环境</h2><h3 id="1-、什么是集成开发环境【简称：IDE】"><a href="#1-、什么是集成开发环境【简称：IDE】" class="headerlink" title="1 、什么是集成开发环境【简称：IDE】"></a>1 、什么是集成开发环境【简称：IDE】</h3><ul>
<li>集成开发环境讲究一站式开发，使用这个工具即可。有提示功能，有自动纠错功能。</li>
<li>集成开发环境可以让软件开发变得更简单。更高效</li>
<li>没有IDE工具：<br>需要安装JDK、需要配置环境变量、需要手动的将java源文件编译生成class字节码文件。<br>java源程序出错之后没有提示。<br>没有自动提示功能等。</li>
<li>有IDE工具：<br>不需要独立安装JDK【IDE中已经集成】。<br>不需要手动配置环境变量。<br>不需要使用javac命令对java源文件进行编译。<br>并且java源程序编写语法错误马上提示。<br>使用IDE工具有很多代码不需要写，自动生成了。</li>
</ul>
<h3 id="2、-java有哪些比较主流的IDE呢？"><a href="#2、-java有哪些比较主流的IDE呢？" class="headerlink" title="2、 java有哪些比较主流的IDE呢？"></a>2、 java有哪些比较主流的IDE呢？</h3><ul>
<li>eclipse（myeclipse）【最多】</li>
<li>Intellij IDEA【上升趋势最大】</li>
<li>Netbeans</li>
<li>JBuilder<br>…</li>
</ul>
<h3 id="3-、IDE常见的知识"><a href="#3-、IDE常见的知识" class="headerlink" title="3 、IDE常见的知识"></a>3 、IDE常见的知识</h3><p><strong>workspace：</strong> 工作区<br>在workspace工作区中有一个文件夹：<strong>.metadata</strong>：储存IDE工作状态。<br>企业级开发：JavaEE开发的专用布局 - Java Enterprise。<br>普通java开发：JavaSE的专用布局 - Java<br>工作区workspace中基本的单元是：<strong>Project</strong>（工程&#x2F;项目）<br><strong>重点窗口介绍：</strong></p>
<ul>
<li>Package Explore &#x2F; Navigator &#x2F; Project Explore：可以看到java源文件</li>
<li>Console：控制台窗口</li>
</ul>
<h2 id="3、java程序的编译和运行、JDK、JRE、JVM的关系、环境变量、HelloWorld程序"><a href="#3、java程序的编译和运行、JDK、JRE、JVM的关系、环境变量、HelloWorld程序" class="headerlink" title="3、java程序的编译和运行、JDK、JRE、JVM的关系、环境变量、HelloWorld程序"></a>3、java程序的编译和运行、JDK、JRE、JVM的关系、环境变量、HelloWorld程序</h2><h3 id="1、Java的加载与执行"><a href="#1、Java的加载与执行" class="headerlink" title="1、Java的加载与执行"></a><strong>1、Java的加载与执行</strong></h3><p>*Java程序的运行包括两个非常重要的阶段<br>-编译阶段<br>-运行阶段</p>
<p>*<strong>编译阶段</strong></p>
<p>编译阶段主要的任务是检查Java源程序是否符合Java语法</p>
<p>符合Java语法则能够生成正常的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E7%A0%81&spm=1001.2101.3001.7020">字节码</a>文件（.class）<br>不符合Java语法规则则无法生成字节码文件</p>
<p>字节码文件不是单纯的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&spm=1001.2101.3001.7020">二进制</a>，这种文件无法在操作系统中直接执行。<br><strong>javac.exe（Java编译程序，在JDK中自带）</strong><br>怎么使用？在哪用？<br>在DOS命令窗口中使用。<br>**javac的使用规则：**<em><strong>javac java源文件的路径</strong></em></p>
<p>class文件是最终要执行的文件，所以class文件生成之后，java源文件删除也不影响java程序执行。<br>*编译结束后，可以将class文件拷贝到其他操作系统当中运行。【跨平台性】</p>
<p>*<strong>运行阶段</strong><br>JDK安装之后，除了自带的javac.exe之外，还有另外一个工具，叫做java.exe，其主要负责运行阶段。</p>
<p>java.exe在哪里用？怎么用？<br>-在DOS窗口使用<br><strong>-使用方法</strong> 输入 <strong>java 类名</strong></p>
<p>java.exe命令会启动Java虚拟机（<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=JVM&spm=1001.2101.3001.7020">JVM</a>），JVM会启动类加载器ClassLoader<br>ClassLoader会去硬盘上搜索A.class文件，找到该文件则将该字节码文件装载到JVM中。<br>JVM将A.class字节码文件解释成二进制。<br>然后操作系统执行二进制和底层硬件平台进行交互。</p>
<h3 id="2、JDK、JRE、JVM的关系"><a href="#2、JDK、JRE、JVM的关系" class="headerlink" title="2、JDK、JRE、JVM的关系"></a>2、JDK、JRE、JVM的关系</h3><p><em><strong>JDK</strong></em>：开发者提供的开发工具箱，是给程序开发者用的，它包括完整的jre、Java运行环境，还包括了其他供开发者使用的工具包。</p>
<p><em><strong>JRE:</strong></em> 运行时所必须的包依赖的环境都在jre中</p>
<p><em><strong>JVM：</strong></em> 当我们运行一个程序时，JVM负责将字节码转换为特定机器代码，JVM提供了内存管理、垃圾回收和安全机制等，他独立于硬件和操作系统，正是java程序可以一次编写多处执行的原因</p>
<p>JDK目录的介绍：<br>JDK&#x2F;bin： 该目录下存放很多命令，例如javac.exe和java.exe<br>javac.exe负责编译<br>java.exe负责运行</p>
<p><strong>开发HelloWorld程序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//public表示一个公开的</span><br><span class="hljs-comment">//class表示一个类</span><br><span class="hljs-comment">//HelloWorld表示一个类名</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span>&#123;<span class="hljs-comment">//表示定义一个公开的类，起名HelloWorld</span><br><span class="hljs-comment">//类体中不允许直接编写Java语句（除声明变量之外）</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	public表示公开的</span><br><span class="hljs-comment">	static表示静态的</span><br><span class="hljs-comment">	void表示空</span><br><span class="hljs-comment">	main表示方法名是main</span><br><span class="hljs-comment">	(String[] args)是一个main方法的形式参数列表</span><br><span class="hljs-comment">	需要记住的是：以下的方法是一个程序的主方法。是程序的执行入口，是一个固定编写方式。</span><br><span class="hljs-comment">*/</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main （String[] args）&#123;<span class="hljs-comment">//表示定义一个公开的静态的主方法</span><br>	<span class="hljs-comment">//方法体</span><br>	<span class="hljs-comment">//方法体</span><br><br>	<span class="hljs-comment">//Java语句以&quot;;&quot;终止，分号必须是半角分号</span><br>		System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<span class="hljs-comment">//向控制台输出语句</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将HelloWorld.java源程序通过javac工具编译：<br>首先需要解决的问题是：javac命令是否可用<br>打开DOS命令窗口，直接输入javac</p>
<p>*<strong>重要</strong><br>PATH<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020">环境变量</a>的配置<br>*注意：path环境变量和java语言没有关系，path环境变量是属于windows操作系统的一个知识点。path环境变量是专门给windows操作系统指路的。·</p>
<h2 id="4、公开类、标识符、关键字"><a href="#4、公开类、标识符、关键字" class="headerlink" title="4、公开类、标识符、关键字"></a>4、公开类、标识符、关键字</h2><blockquote>
<p><strong>1、public class与class的区别</strong><br>*一个java源文件中可以定义多个class</p>
<p>*一个java源文件当中public的class不是必须的</p>
<p>*一个class会定义生成一个xxx.class<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E7%A0%81&spm=1001.2101.3001.7020">字节码</a>文件</p>
<p>*一个java源文件当中定义公开的类的话，public class只能有一个，且该类名称必须和java源文件名称一致。</p>
<p>*每一个class当中都可以编写main方法，都可以设定程序的入口，想执行B.class中的main方法：<strong>java B</strong>， 想执行X.class当中的main方法 <strong>：java X</strong><br>注意：当在命令窗口中执行java Hello，那么要求Hello.class当中必须有主方法。没有主方法会出现运行阶段的错误。</p>
<p><strong>2、标识符</strong><br>1 什么是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%A0%87%E8%AF%86%E7%AC%A6&spm=1001.2101.3001.7020">标识符</a>？</p>
<blockquote>
<p>-在java源程序中凡是程序员有权利自己命名的单词都是标识符。<br>-标识符在EditPlus编辑器中以黑色高亮显示</p>
</blockquote>
<p>2 标识符的命名规则？</p>
<blockquote>
<p>*一个合法的标识符只能由“数字、字母、下划线_、美元符号$”组成，不能含有其他的符号。<br>*不能以数字开头<br>*严格区分大小写<br>*关键字不能做标识符<br>*理论上无长度限制，但是最好不要太长</p>
</blockquote>
<p>3 标识符的命名规范？（只是一种规范，不属于语法，编译器不报错）</p>
<blockquote>
<p>*<strong>最好见名知意</strong></p>
</blockquote>
<blockquote>
<p>*<strong>遵守驼峰命名规则</strong><br><strong>SystemService</strong><br><strong>UserService</strong><br><strong>CustomerService</strong></p>
</blockquote>
<blockquote>
<p>*<strong>类名、接口名：首字母大写，后面每个单词首字母大写。</strong><br>*<strong>变量名、方法名：首字母小写，后面每个单词首字母大写。</strong><br>*<strong>常量名：全部大写。</strong></p>
</blockquote>
<p>4 合法和不合法的标识符</p>
<table>
<thead>
<tr>
<th>合法</th>
<th>不合法</th>
</tr>
</thead>
<tbody><tr>
<td>_123Test</td>
<td>123Test</td>
</tr>
<tr>
<td>HelloWorld</td>
<td>Hello-World</td>
</tr>
<tr>
<td>A_B_C</td>
<td>Hello World</td>
</tr>
<tr>
<td>$ABC</td>
<td>HelloWorld#</td>
</tr>
<tr>
<td>public1</td>
<td>public</td>
</tr>
</tbody></table>
<p><strong>3、关键字及含义</strong></p>
<p>在Java中关键字都是小写</p>
<blockquote>
<p>abstract 表明类或者成员方法具有抽象属性</p>
</blockquote>
<blockquote>
<p>assert 断言，用来进行程序调试</p>
</blockquote>
<blockquote>
<p>boolean 基本数据类型之一，声明布尔类型的关键字</p>
</blockquote>
<blockquote>
<p>break 提前跳出一个块</p>
</blockquote>
<blockquote>
<p>byte 基本数据类型之一，字节类型</p>
</blockquote>
<blockquote>
<p>case 用在switch语句之中，表示其中的一个分支 catch 用在异常处理中，用来捕捉异常</p>
</blockquote>
<blockquote>
<p>char 基本数据类型之一，字符类型</p>
</blockquote>
<blockquote>
<p>class 声明一个类</p>
</blockquote>
<blockquote>
<p>const 保留关键字，没有具体含义</p>
</blockquote>
<blockquote>
<p>continue 回到一个块的开始处</p>
</blockquote>
<blockquote>
<p>default 默认，例如，用在switch语句中，表明一个默认的分支。Java8 中也作用于声明接口函数的默认实现</p>
</blockquote>
<blockquote>
<p>do 用在do-while循环结构中</p>
</blockquote>
<blockquote>
<p>double 基本数据类型之一，双精度浮点数类型</p>
</blockquote>
<blockquote>
<p>else 用在条件语句中，表明当条件不成立时的分支</p>
</blockquote>
<blockquote>
<p>enum 枚举</p>
</blockquote>
<blockquote>
<p>extends 表明一个类型是另一个类型的子类型。对于类，可以是另一个类或者抽象类；对于接口，可以是另一个接口</p>
</blockquote>
<blockquote>
<p>final 用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量</p>
</blockquote>
<blockquote>
<p>finally 用于处理异常情况，用来声明一个基本肯定会被执行到的语句块</p>
</blockquote>
<blockquote>
<p>float 基本数据类型之一，单精度浮点数类型</p>
</blockquote>
<blockquote>
<p>for 一种循环结构的引导词</p>
</blockquote>
<blockquote>
<p>goto 保留关键字，没有具体含义</p>
</blockquote>
<blockquote>
<p>if 条件语句的引导词</p>
</blockquote>
<blockquote>
<p>implements 表明一个类实现了给定的接口</p>
</blockquote>
<blockquote>
<p>import 表明要访问指定的类或包</p>
</blockquote>
<blockquote>
<p>instanceof 用来测试一个对象是否是指定类型的实例对象</p>
</blockquote>
<blockquote>
<p>int 基本数据类型之一，整数类型</p>
</blockquote>
<blockquote>
<p>interface 接口</p>
</blockquote>
<blockquote>
<p>long 基本数据类型之一，长整数类型</p>
</blockquote>
<blockquote>
<p>native 用来声明一个方法是由与计算机相关的语言（如C&#x2F;C++&#x2F;FORTRAN语言）实现的</p>
</blockquote>
<blockquote>
<p>new 用来创建新实例对象</p>
</blockquote>
<blockquote>
<p>package 包</p>
</blockquote>
<blockquote>
<p>private 一种访问控制方式：私用模式</p>
</blockquote>
<blockquote>
<p>protected 一种访问控制方式：保护模式</p>
</blockquote>
<blockquote>
<p>public 一种访问控制方式：共用模式</p>
</blockquote>
<blockquote>
<p>return 从成员方法中返回数据</p>
</blockquote>
<blockquote>
<p>short 基本数据类型之一,短整数类型</p>
</blockquote>
<blockquote>
<p>static 表明具有静态属性</p>
</blockquote>
<blockquote>
<p>strictfp 用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范</p>
</blockquote>
<blockquote>
<p>super 表明当前对象的父类型的引用或者父类型的构造方法</p>
</blockquote>
<blockquote>
<p>switch 分支语句结构的引导词</p>
</blockquote>
<blockquote>
<p>synchronized 表明一段代码需要同步执行</p>
</blockquote>
<blockquote>
<p>this 指向当前实例对象的引用</p>
</blockquote>
<blockquote>
<p>throw 抛出一个异常</p>
</blockquote>
<blockquote>
<p>throws 声明在当前定义的成员方法中所有需要抛出的异常</p>
</blockquote>
<blockquote>
<p>transient 声明不用序列化的成员域</p>
</blockquote>
<blockquote>
<p>try 尝试一个可能抛出异常的程序块</p>
</blockquote>
<blockquote>
<p>void 声明当前成员方法没有返回值</p>
</blockquote>
<blockquote>
<p>volatile 表明两个或者多个变量必须同步地发生变化</p>
</blockquote>
<blockquote>
<p>while 用在循环结构中</p>
</blockquote>
</blockquote>
<h1 id="二、数据类型【编程基础】"><a href="#二、数据类型【编程基础】" class="headerlink" title="二、数据类型【编程基础】"></a>二、数据类型【编程基础】</h1><h2 id="1、字面值、变量、数据类型基础、编码方式"><a href="#1、字面值、变量、数据类型基础、编码方式" class="headerlink" title="1、字面值、变量、数据类型基础、编码方式"></a>1、字面值、变量、数据类型基础、编码方式</h2><p><strong>1、字面值</strong><br>关于字面值</p>
<blockquote>
<p>— 10&#x2F;100<br>— 3.14<br>—“abc”<br>—‘a’<br>—true、false</p>
</blockquote>
<p>字面值 就是数据。<br>字面值 是Java源程序的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86&spm=1001.2101.3001.7020">组成部分</a>之一。包括标识符和它的关键字，他们都是Java源程序的组成部分。</p>
<p>数据在现实世界中是分类别的，所以数据在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%AE%A1%E7%AE%97%E6%9C%BA&spm=1001.2101.3001.7020">计算机</a>编程语言中也是有类型的：【数据类型】</p>
<blockquote>
<p>10、100 属于整数型<br>3.14 属于浮点型<br>true、false 属于布尔型<br>“abc”、“张广荣” 属于字符串型<br>‘A’、‘人’ 属于字符型</p>
</blockquote>
<p>注意：<br>Java语言中所有字符串型字面值必须用双引号括起来，双引号是半角。<br>Java语言中所有字符型字面值必须用单引号括起来，单引号是半角。</p>
<p><strong>2、变量</strong></p>
<p>1 什么是变量？</p>
<blockquote>
<p>变量本质上说是内存中的一块空间，这块空间“有数据类型”、“有名字”、“有字面值”。<br>变量包含三部分：数据类型、名称、字面值【数据】<br>变量是内存中存储数据的最基本的单元。</p>
</blockquote>
<p>2 数据类型的作用？</p>
<blockquote>
<p>不同的数据类型底层会分配不同大小的空间。<br>数据类型是指导程序在运行阶段应该分配多大的内存空间。</p>
</blockquote>
<p>3 变量要求：变量中存储的具体的“数据”必须和变量的“数据类型”一致，当不一致的时候编译报错</p>
<p>4 声明&#x2F;定义变量的语法格式：</p>
<blockquote>
<p><strong>数据类型 变量名</strong><br>数据类型：概念在第三部分。<br>eg：int 整数型<br>变量名：只要是合法的标识符就行。规范中要求：首字母小写，后面每个单词首字母大写。</p>
</blockquote>
<p>5 变量声明之后怎么赋值？</p>
<blockquote>
<p>语法格式： <strong>变量名&#x3D;字面值</strong><br>要求：字面值的数据类型必须和变量的数据类型一致。<br>&#x3D;等号是一个运算符，叫做赋值运算符，赋值运算符优先运算等号右边的表达式，表达式执行结束之后的结果赋值给等式左边的变量。</p>
</blockquote>
<p>6 声明和赋值可以放到一起完成。</p>
<blockquote>
<p>int i&#x3D;10</p>
</blockquote>
<p>7 变量赋值之后，可以重新赋值，变量的值可以变化：</p>
<blockquote>
<p>int i&#x3D;10；<br>System.out.println(i);<br>i&#x3D;20;<br>System.out.println(i);<br>i&#x3D;100;<br>System.out.println(i);</p>
</blockquote>
<p>8 有了变量的概念之后，内存空间得到了重复的使用：</p>
<blockquote>
<p>int i&#x3D;10;<br>System.out.println(i);<br>System.out.println(i);<br>System.out.println(i);<br>…</p>
</blockquote>
<p>9 通常访问一个变量包括两种访问形式：</p>
<blockquote>
<p>第一种：读取变量中保存的具体数据 get&#x2F;获取<br>第二种：修改变量中保存的具体数据 set&#x2F;设置<br>i&#x3D;10; &#x2F;&#x2F;set<br>System.out.println(i); &#x2F;&#x2F;get</p>
</blockquote>
<p>10 变量在一行可以声明多个</p>
<p>11 Java中的变量必须先声明，再赋值，才能访问。</p>
<blockquote>
<p>int i; &#x2F;&#x2F;程序执行到这里，内存空间并没有开辟出来，变量i并没有初始化。所以没有赋值之前是无法访问的。</p>
</blockquote>
<p>12 关于Java变量的作用域</p>
<blockquote>
<p>什么是作用域？<br>变量的作用域，其实描述的就是变量的有效范围。在什么范围之内是可以被访问的，只要出了这个范围该变量就无法访问了。</p>
</blockquote>
<blockquote>
<p>变量的作用域只要记住一句话：出了大括号就不认识了。</p>
</blockquote>
<p>13 关于变量的分类：</p>
<blockquote>
<p>关于变量声明的位置来分类：<br><strong>局部变量：</strong> 在方法体中声明的变量。<br><strong>成员变量：</strong> 在方法体【类体之内】声明的变量叫做成员变量。<br>在不同的作用域当中，变量名可以相同。<br>在同一个作用域当中，变量名不能重名。</p>
</blockquote>
<p><strong>3、数据类型</strong></p>
<p>1 数据类型的作用是什么？</p>
<blockquote>
<p>程序当中有很多数据，每一个数据都是有相关类型的，不同数据类型的数据占用空间大小不同。<br>数据类型的作用是指导JVM在运行程序的时候給该数据分配多少空间。</p>
</blockquote>
<p>2 Java中的数据类型包括两种</p>
<blockquote>
<p>基本数据类型<br>引用数据类型</p>
</blockquote>
<p>3 关于基本数据类型</p>
<blockquote>
<p>基本数据类型包括四大类八小种：<br>第一类：整数型 （byte，short，int，long）<br>第二类：浮点型 （float，double）<br>第三类：布尔型 （boolean）<br>第四类：字符型 （char）</p>
</blockquote>
<p>4 字符串“abc”不属于基本数据类型，属于 <strong>“引用数据类型”</strong> ，字符属于基本数据类型：</p>
<blockquote>
<p>字符串使用双引号 “ ”<br>字符使用单引号 ‘ ’</p>
</blockquote>
<p>5 八钟基本数据类型各自占用空间大小是多少？</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>占用空间大小 【单位：字节】</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1</td>
<td>-128~127</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>·32768~32767</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>·263~263-1</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>有效位6~7位</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>有效位15位</td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
<td>true，false</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td>0~65535</td>
</tr>
<tr>
<td>6 计算机在任何情况下都只能识别二进制。例如：只认识010101010100101…</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>文字与二进制通过字符编码的方式进行对照转换，最先出现的是ASCII码【采用一个字节编码】</strong></p>
<blockquote>
<p>支持简体中文的编码方式是GB2312&lt; GBK&lt; GB18030<br>支持繁体中文：&lt; big5 &gt;<br>后来出现了一种方式统一了全球所有文字，容量较大，这种编码方式叫做：Unicode编码<br>unicode编码方式有多种具体的实现：</p>
<ul>
<li>UTF-8</li>
<li>UTF-16</li>
<li>UTF-32</li>
</ul>
</blockquote>
<p>Java语言采用的编码方式是unicode编码方式，所以“标识符”可以用中文。</p>
<h2 id="2、char、转义、整数型、精度损失"><a href="#2、char、转义、整数型、精度损失" class="headerlink" title="2、char、转义、整数型、精度损失"></a>2、char、转义、整数型、精度损失</h2><p>关于八种基本数据类型的默认值</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>byte，short，int，long</td>
<td>0</td>
</tr>
<tr>
<td>float，double</td>
<td>0.0</td>
</tr>
<tr>
<td>boolean</td>
<td>false【在C语言中true是1，false是0】</td>
</tr>
<tr>
<td>char</td>
<td>\u0000</td>
</tr>
</tbody></table>
<blockquote>
<p>成员变量没有手动赋值系统会默认赋值【局部变量则不会】<br>八钟基本数据类型的默认值都是一切向0看齐。</p>
</blockquote>
<h3 id="1、char型"><a href="#1、char型" class="headerlink" title="1、char型"></a>1、char型</h3><blockquote>
<p>一个中文占用2个字节，char类型正好是2个字节<br>所以Java中的char类型变量可以存储一个中文字符<br>“ab”是字符串不能用单引号括起来</p>
</blockquote>
<h3 id="2、转义字符-（-）"><a href="#2、转义字符-（-）" class="headerlink" title="2、转义字符 （\）"></a>2、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6&spm=1001.2101.3001.7020">转义字符</a> （\）</h3><p>\ ：反斜杠在Java语言中具有转义功能</p>
<blockquote>
<p><strong>\n ：</strong> 换行符<br>System.out.println与 print 的区别：println输出之后换行，print表示输出，但是不换行。<br><strong>\t ：</strong> 制表符 ，即Tab键<br><strong>\ ’ ：</strong> 普通的单引号<br><strong>\ \ ：</strong> 普通的反斜杠<br><strong>\ “ ：</strong> 普通的双引号</p>
</blockquote>
<p><strong>怎样在控制台输出“反斜杠字符”？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> k=<span class="hljs-string">&#x27;\\&#x27;</span>;<br>System.out.println();<br></code></pre></td></tr></table></figure>

<p>第一个反斜杠具有转义功能，将后面的反斜杠转义为p普通的反斜杠字符<br><strong>结论：因此在Java中两个反斜杠代表一个普通的反斜杠字符</strong></p>
<p><strong>怎样在控制台输出一个普通的单引号？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> a=<span class="hljs-string">&#x27;\&#x27;&#x27;</span>; / / 反斜杠具有转义功能，将第二个单引号转换成普通的单引号字符，第一个单引号和最后一个单引号配对。<br>System.out.println(a);<br></code></pre></td></tr></table></figure>

<h3 id="3、整数型"><a href="#3、整数型" class="headerlink" title="3、整数型"></a>3、整数型</h3><p>1 Java语言当中的“整数型字面值”被默认当做int处理。要让这个“这个整数型字面值”被当做long类型处理的话，需要在“整数型字面值”后面添加1&#x2F;L，建议使用大写的L。</p>
<p><strong>2 Java语言当中的整数型字面值有三种表现方式：</strong></p>
<blockquote>
<p>第一种方式：十进制【是一种缺省默认的方式】 <em>int i&#x3D;10</em><br>第二种方式：八进制【在编写八进制整数型字面值的时候需要以0开始】 <em>int i&#x3D;010</em><br>第三种方式：十六进制【在编写十六进制整数型字面值的时候需要以0x开始】 <em>int i&#x3D;0x10</em></p>
</blockquote>
<p><strong>long y&#x3D;2147483648L</strong></p>
<blockquote>
<p>long y&#x3D;2147483648<br>2147483648是一个过大整数，被当做int类型4个字节处理，但是这个字面值超过int类型范围<br>解决方法：<br>在字面值后面添加L，将其当做long类型处理，y是类型变量，以上程序不存在类型转换。</p>
</blockquote>
<h3 id="4、精度损失"><a href="#4、精度损失" class="headerlink" title="4、精度损失"></a>4、精度损失</h3><p>计算机二进制有三种表示形式：</p>
<blockquote>
<p>原码<br>反码<br>补码</p>
</blockquote>
<p>计算机在任何情况下底层表示和存储数据的时候采用了补码形式。</p>
<blockquote>
<p>正数的补码：和原码相同。<br>负数的补码：负数的绝对值对应的二进制所有二进制位取反，再加1</p>
</blockquote>
<p>当一个整数字面值没有超过byte，short，char的取值范围，这个字面值可以直接赋值给byte，short，char类型的变量。这种机制被SUN允许了，目的是为了方便程序员编程。</p>
<blockquote>
<p>char cc&#x3D;65535 &#x2F;&#x2F;通过<br>char cc&#x3D;65536 &#x2F;&#x2F;编译报错</p>
</blockquote>
<h2 id="3、浮点型、布尔型、类型转换、算数运算符、关系运算符、逻辑运算符"><a href="#3、浮点型、布尔型、类型转换、算数运算符、关系运算符、逻辑运算符" class="headerlink" title="3、浮点型、布尔型、类型转换、算数运算符、关系运算符、逻辑运算符"></a>3、浮点型、布尔型、类型转换、算数运算符、关系运算符、逻辑运算符</h2><h3 id="1、浮点型"><a href="#1、浮点型" class="headerlink" title="1、浮点型"></a><strong>1、浮点型</strong></h3><blockquote>
<p>float 单<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%B2%BE%E5%BA%A6&spm=1001.2101.3001.7020">精度</a>【4个字节】<br>double 双精度【8个字节，精度较高】</p>
</blockquote>
<p>在Java语言当中，所有的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%B5%AE%E7%82%B9&spm=1001.2101.3001.7020">浮点</a>字面值【3.0】，默认被当做double类型来处理。<br>要想该字面值当做float类型来处理，需要在字面值后面添加F&#x2F;f</p>
<p>注意：<br>double和float在计算机内部<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&spm=1001.2101.3001.7020">二进制</a>存储的时候存储的都是近似值。<br>在现实世界当中有一些数字是无限循环的，列如：3.3333333…<br>计算机资源是有限的，用有限的资源存储无限的数据只能存储近似值。</p>
<h3 id="2、布尔型"><a href="#2、布尔型" class="headerlink" title="2、布尔型"></a><strong>2、布尔型</strong></h3><p>关于布尔型数据类型：<strong>boolean</strong></p>
<blockquote>
<p>在Java语言当中<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=boolean&spm=1001.2101.3001.7020">boolean</a>类型只有两个值：true、false，没有其他值。<br>不像C语言当中，0和1可以表示假和真。</p>
</blockquote>
<blockquote>
<p>在底层存储的时候boolean类型占用1个字节，因为实际存储的时候false底层是0，true底层是1.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B&spm=1001.2101.3001.7020">布尔类型</a>在实际开发当中非常需要，经常使用<strong>逻辑运算</strong>和<strong>条件控制语句</strong>当中。</p>
<h3 id="3、类型转换"><a href="#3、类型转换" class="headerlink" title="3、类型转换"></a><strong>3、类型转换</strong></h3><p>关于基本数据类型之间的互相转换：</p>
<p><strong>转换规则：</strong></p>
<blockquote>
<p>1 八种基本数据类型当中除布尔类型之外剩下的7种类型之间都可以互相转换。</p>
</blockquote>
<blockquote>
<p>2 小容量向大容量转换，称为自动<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&spm=1001.2101.3001.7020">类型转换</a>，容量从小到大排序：<br><strong>byte &lt; short ，char &lt; int &lt; long &lt; float &lt; double</strong><br>注： 任何浮点类型不管占用多少个字节，都比整数型容量大。<br>char 和 short可表示的种类数量相同，但是char可以取更大的正整数 。</p>
</blockquote>
<blockquote>
<p>3 大容量转换成小容量，叫做强制类型转换，需要加强制类型转换符，程序才能编译通过，但是在运行阶段可能会损失精度，所以谨慎使用。</p>
</blockquote>
<blockquote>
<p>4 当整数字面值没有超出byte，short，char的取值范围，可以直接赋值给byte，short，char类型的变量。</p>
</blockquote>
<blockquote>
<p>5 byte，short，char混合运算的时候，各自先转换成int类型再做运算。</p>
</blockquote>
<blockquote>
<p>6 多种数据类型混合运算，先转换成容量最大的那种类型再做运算。</p>
</blockquote>
<h3 id="4、算数运算符"><a href="#4、算数运算符" class="headerlink" title="4、算数运算符"></a><strong>4、算数运算符</strong></h3><p>关于Java编程中的运算符之：算数运算符</p>
<table>
<thead>
<tr>
<th>+</th>
<th>求和</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>相减</td>
</tr>
<tr>
<td>*</td>
<td>乘积</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>商</td>
</tr>
<tr>
<td>%</td>
<td>取余数【取模】</td>
</tr>
<tr>
<td>++</td>
<td>自加1</td>
</tr>
<tr>
<td>- -</td>
<td>自减1</td>
</tr>
</tbody></table>
<p>小结：++运算符可以出现在变量前，也可以出现在变量后，，无论是变量前还是变量后只要++运算结束，该变量中的值一定会自加1</p>
<blockquote>
<p>++a：先自增1，在进行运算。<br>a++：先运算，再自增1。</p>
</blockquote>
<h3 id="5、关系运算符"><a href="#5、关系运算符" class="headerlink" title="5、关系运算符"></a><strong>5、关系运算符</strong></h3><table>
<thead>
<tr>
<th>&gt;</th>
<th>大于</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
</tr>
<tr>
<td>&#x3D;&#x3D;</td>
<td>等于</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不等于</td>
</tr>
</tbody></table>
<blockquote>
<p>&#x3D; 是赋值运算符；<br>&#x3D;&#x3D; 是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6&spm=1001.2101.3001.7020">关系运算符</a>；<br>关系运算符的结果一定是布尔类型。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperatorTest</span><br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>		<span class="hljs-type">int</span> b=<span class="hljs-number">10</span>;<br><br>		System.out.println(a&gt;b); <span class="hljs-comment">//false</span><br>		System.out.println(a&gt;=b); <span class="hljs-comment">//ture</span><br>		System.out.println(a&lt;b); <span class="hljs-comment">//false</span><br>		System.out.println(a&lt;=b); <span class="hljs-comment">//true</span><br>		System.out.println(a==b); <span class="hljs-comment">//true</span><br>		System.out.println(a!=b); <span class="hljs-comment">//false</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6、逻辑运算符"><a href="#6、逻辑运算符" class="headerlink" title="6、逻辑运算符"></a><strong>6、逻辑运算符</strong></h3><table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>逻辑与 （两边的算子都是true，结果才是true）</td>
</tr>
<tr>
<td>！</td>
<td>逻辑非（取反，！false就是true，！true就是假，这是一个单目运算符）</td>
</tr>
<tr>
<td>^</td>
<td>逻辑异或（两边的算子只要不一样，结果就是true）</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>短路与（第一个表达式执行结果是false，会发生短路与）</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>| 逻辑或（两边的算子只要有一个是true，结果就是true）</strong><br><strong>|| 短路或（第一个表达式执行结果是true，会发生短路或）</strong></p>
</blockquote>
<p>1 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6&spm=1001.2101.3001.7020">逻辑运算符</a>要求两边的算子都是布尔类型，并且逻辑运算符最终的运算结果也是一个布尔类型。</p>
<p>2 短路与和逻辑与最终的运算结果是相同的，只不过短路与存在短路现象。<br>3 短路或和逻辑或最终的运算结果是相同的，只不过短路或存在短路现象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">** 逻辑与和短路与的区别** <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test01</span><br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">int</span> x=<span class="hljs-number">10</span>;<br>		<span class="hljs-type">int</span> y=<span class="hljs-number">8</span>;<br>		System.out.println(x &lt; y&amp; ++x &lt; y); <span class="hljs-comment">//进行了++x的操作</span><br>		System.out.println(x); <span class="hljs-comment">//x=11</span><br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test02</span><br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">int</span> x=<span class="hljs-number">10</span>;<br>		<span class="hljs-type">int</span> y=<span class="hljs-number">8</span><br>		System.out.println(x &lt; y&amp; ++x &lt; y); <span class="hljs-comment">//因为x&lt;y是false，直接短路，后面的操作就不在执行</span><br>		System.out.println(x); <span class="hljs-comment">//x=10</span><br>		&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从某个角度来看，短路与更智能。由于后面的表达式可能不执行，所以执行效率较高。这种方式在实际开发中使用较多。短路与比逻辑与使用的多。短路与更常用。</p>
<p>但是，在某些特殊的逻辑业务中，要求运算符两边的算子必须全部执行，此时必须使用逻辑与，不能使用短路与，使用短路与可能导致右边的表达式不执行。</p>
<h2 id="4、赋值运算符、字符串连接运算符、三目运算符-三元运算符-条件运算符"><a href="#4、赋值运算符、字符串连接运算符、三目运算符-三元运算符-条件运算符" class="headerlink" title="4、赋值运算符、字符串连接运算符、三目运算符&#x2F;三元运算符&#x2F;条件运算符"></a>4、赋值运算符、字符串连接运算符、三目运算符&#x2F;三元运算符&#x2F;条件运算符</h2><h3 id="1、赋值运算符"><a href="#1、赋值运算符" class="headerlink" title="1、赋值运算符"></a>1、赋值运算符</h3><p>java中赋值类运算符包括两种：</p>
<blockquote>
<p>基本的赋值运算符：&#x3D;<br>扩展的赋值运算符：+&#x3D;、-+、*&#x3D;、&#x2F;+、%&#x3D;</p>
</blockquote>
<p>赋值类的运算符优先级：先执行等号右边的表达式，将执行结果赋值给左边的变量。</p>
<p>注意以下代码：</p>
<blockquote>
<p>byte x&#x3D;10；<br>x +&#x3D; 5；&#x2F;&#x2F;<strong>并不等同于：x &#x3D;x+5，而等同于：x&#x3D; (byte)(x+5)</strong></p>
</blockquote>
<blockquote>
<p>int y&#x3D;10;<br>y +&#x3D; 5; &#x2F;&#x2F;<strong>等同于：y&#x3D; (int)(y+5)</strong></p>
</blockquote>
<blockquote>
<p>long a&#x3D;10L;<br>int b&#x3D;20;<br>b +&#x3D; a; &#x2F;&#x2F; <strong>等同于：b &#x3D; (int)(b+a)</strong></p>
</blockquote>
<p><strong>重要结论：扩展类的赋值运算符不改变运算结果类型，假设最初这个变量的类型是byte类型，无论怎么追加或追减，最终该变量的数据类型还是byte类型。</strong></p>
<h3 id="2、字符串连接运算符"><a href="#2、字符串连接运算符" class="headerlink" title="2、字符串连接运算符"></a>2、字符串连接运算符</h3><p>关于java中的 “+” 运算符：</p>
<p>1 +运算符在java语言中当中有两个作用：</p>
<blockquote>
<p>加法运算<br>字符串的连接运算</p>
</blockquote>
<p>2 数字+数字 →数字【求和】<br>数字+“字符串” →“字符串”【字符串连接】</p>
<p>3 在一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%A1%A8%E8%BE%BE%E5%BC%8F&spm=1001.2101.3001.7020">表达式</a>当中可以出现多个“+”，在没有添加小括号的前提下，遵循自左向右的顺序依次运算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>		<span class="hljs-type">int</span> b=<span class="hljs-number">20</span>;<br>		System.out.println(<span class="hljs-string">&quot;10+20=30&quot;</span>);  <span class="hljs-comment">//在控制台输出“10+20=30”</span><br>		System.out.println(<span class="hljs-string">&quot;10+20=&quot;</span>+a+b);  <span class="hljs-comment">//以动态方式输出“10+20=1020”</span><br>		System.out.println(<span class="hljs-string">&quot;10+20=&quot;</span>+(a+b)); <span class="hljs-comment">//输出10+20=30</span><br>	&#125;<br>&#125;<br><span class="hljs-number">123456789</span><br></code></pre></td></tr></table></figure>

<p>String是引用数据类型，s是变量名，“abc”是String类型的字面值</p>
<blockquote>
<p><strong>String s&#x3D;“abc”</strong></p>
</blockquote>
<h3 id="3、三元运算符"><a href="#3、三元运算符" class="headerlink" title="3、三元运算符"></a>3、三元运算符</h3><p><strong>三元运算符&#x2F;三目运算符&#x2F;条件运算符</strong><br><strong>1、语法规则：</strong></p>
<blockquote>
<p><strong>布尔表达式？表达式1：表达式2</strong></p>
</blockquote>
<p><strong>2、三元运算符的执行原理</strong></p>
<blockquote>
<p>当布尔表达式的结果是true的时候，选择表达式1作为整个表达式的执行结果<br>当布尔表达式的结果是false的时候，选择表达式2作为整个表达式的执行结果</p>
</blockquote>
<h1 id="三、流程控制语句"><a href="#三、流程控制语句" class="headerlink" title="三、流程控制语句"></a>三、流程控制语句</h1><h2 id="1、控制语句、java输入语句、if语句"><a href="#1、控制语句、java输入语句、if语句" class="headerlink" title="1、控制语句、java输入语句、if语句"></a>1、控制语句、java输入语句、if语句</h2><p>Java控制语句可以分为7种：</p>
<blockquote>
<p><strong>控制选择结构语句</strong></p>
<ul>
<li><strong>if、if else</strong></li>
<li><strong>switch</strong></li>
</ul>
</blockquote>
<blockquote>
<p><strong>控制循环结构语句</strong></p>
<ul>
<li><strong>for</strong></li>
<li><strong>while</strong></li>
<li><strong>do while</strong></li>
</ul>
</blockquote>
<blockquote>
<p><strong>改变控制语句顺序</strong></p>
<ul>
<li><strong>break</strong></li>
<li><strong>continue</strong></li>
</ul>
</blockquote>
<p><strong>1、if语句</strong></p>
<p><strong>if语句属于选择结构，if语句又被称为分支语句&#x2F;条件控制语句</strong></p>
<p><strong>1 if语句的语法结构：四种编写方式</strong></p>
<blockquote>
<p><strong>第一种</strong><br>if（布尔表达式）{<br>java语句；<br>java语句；<br>…<br>}</p>
</blockquote>
<blockquote>
<p><strong>第二种</strong><br><strong>if（布尔表达式）</strong>{<br>java语句；<br>java语句；<br>…<br>} <strong>else</strong> {<br>java语句；<br>java语句；<br>…<br>}</p>
</blockquote>
<blockquote>
<p><strong>第三种</strong><br><strong>if（布尔表达式）</strong>{<br>java语句<br>java语句<br>…<br>}<strong>else if（布尔表达式）</strong>{<br>java语句<br>java语句<br>…<br>}<br><strong>else if（布尔表达式）</strong>{<br>java语句<br>java语句<br>…<br>}<strong>else if（布尔表达式）</strong>{<br>java语句<br>java语句<br>…<br>}…</p>
</blockquote>
<blockquote>
<p><strong>第四种</strong><br><strong>if（布尔表达式）</strong>{<br>java语句<br>java语句<br>…<br>}<strong>else if（布尔表达式）</strong>{<br>java语句<br>java语句<br>…<br>}<br><strong>else if（布尔表达式）</strong>{<br>java语句<br>java语句<br>…<br>}<strong>else</strong> {<br>java语句<br>java语句<br>…<br>}…</p>
</blockquote>
<p><strong>2 重点 ：对于java语句中的if语句来说，只要有一个分支执行，整个if语句全部结束。</strong></p>
<p><strong>3 注意：以上的第二种编写方式和第四种编写方式都带有else分支，这两种方式可以保证100%会有分支执行。</strong></p>
<p><strong>4 所有的控制语句都是可以嵌套使用的，只要合理嵌套就行。</strong></p>
<blockquote>
<p>注意：嵌套使用的时候，代码格式要保证完美。【该缩进的时候必须缩进，大部分情况下使用大括号包围的需要缩进】</p>
</blockquote>
<p><strong>5 if语句的分支中只有一条java语句的时候，大括号可以不写。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println();  负责向控制台输出<br></code></pre></td></tr></table></figure>

<p><strong>6 接收用户键盘的输入语句：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyInputTest</span><br>&#123;<br>	publid <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		java.util.<span class="hljs-type">Scanner</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Scanner(System.in); <span class="hljs-comment">//第一步，创建键盘扫描器对象</span><br>		<br>		输入字符：<br>		<span class="hljs-type">String</span> <span class="hljs-variable">UserInputContent</span> <span class="hljs-operator">=</span> s.next(); <br>		<span class="hljs-comment">//第二步：调用Scanner对象的next方法开始接收用户的键盘输入</span><br>		<span class="hljs-comment">//程序执行到这里会停下来，等待用户的输入</span><br>		<span class="hljs-comment">//当用户输入的时候，并且最终敲回车的时候，输入的信息会自动赋值给userInputContent</span><br>		<span class="hljs-comment">//程序执行到这里，用户输入的信息已经到内存中了，</span><br>		System.out.println(<span class="hljs-string">&quot;您输入了:&quot;</span> + UserInputContent).; <span class="hljs-comment">//将内存的数据输入到控制台</span><br>		<br>		输入数字<br>		<span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> s.nextInt(); <span class="hljs-comment">//接收数字 </span><br>		System.out.println(<span class="hljs-string">&quot;您输入的数字是:&quot;</span> + num);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>正确语句：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IfTest01</span><br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">boolean</span> sex=<span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">if</span> (sex)&#123;<br>			System.out.println(<span class="hljs-string">&quot;男&quot;</span>);<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			System.out.println(<span class="hljs-string">&quot;女&quot;</span>);<br>		&#125;<br>	<br>		sex=<span class="hljs-literal">false</span>;<br>		<br>		<span class="hljs-keyword">if</span>(sex) System.out.println(<span class="hljs-string">&quot;男&quot;</span>)； <span class="hljs-keyword">else</span> System.out.println(<span class="hljs-string">&quot;女&quot;</span>)；<br>			<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>错误语句：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IfTest02</span><br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">boolean</span> sex=<span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">if</span>(sex)<br>			System.out.println(<span class="hljs-string">&quot;男&quot;</span>);<br>			System.out.println(<span class="hljs-string">&quot;hehe&quot;</span>); <span class="hljs-comment">//不加大括号的话只包括第一条语句，第二条语句不是if语句的分支java语句</span><br>		<span class="hljs-keyword">else</span> <span class="hljs-comment">//else缺少if</span><br>			System.out.println(<span class="hljs-string">&quot;女&quot;</span>);<br>		&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2、switch控制语句"><a href="#2、switch控制语句" class="headerlink" title="2、switch控制语句"></a>2、switch控制语句</h2><p><strong>关于switch语句：</strong></p>
<p><strong>1、witch语句也属于选择结构，也是分支语句</strong></p>
<p><strong>2、switch语句的语法结构：</strong><br>一个比较完整的switch语句应该这样编写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (<span class="hljs-type">int</span>或String类型的字面值或变量)&#123;<br>	<span class="hljs-keyword">case</span> <span class="hljs-type">int</span>或String类型的字面值或变量:<br>		java语句;<br>		java语句;<br>		...<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> <span class="hljs-type">int</span>或String类型的字面值或变量:<br>		java语句;<br>		java语句;<br>		...<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> <span class="hljs-type">int</span>或String类型的字面值或变量:<br>		java语句;<br>		java语句;<br>		...<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">default</span>:<br>		java语句;<br>		...<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>3、switch语句的执行原理：</strong></p>
<blockquote>
<p>switch语句后面小括号当中的“数据”进行一一匹配，匹配成功的分支执行按照自上而下的顺序依次匹配。</p>
</blockquote>
<p><strong>4、匹配成功的分支执行，分支当中最后有“break；”语句的话，整个switch语句终止。</strong></p>
<p><strong>5、匹配成功的分支执行，分支当中没有“break；”语句的话，直接进入下一个分支执行（不进行匹配），这种现象被称为 case穿透 现象。【提供break；语句可以避免穿透】</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span>穿透：<br><span class="hljs-type">int</span> i=<span class="hljs-number">10</span>；<br><span class="hljs-keyword">switch</span>（i）&#123;<br>	<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>：<br>		java语句;<br>	<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>：<br>		java语句;<br>	<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>： <br>		java语句;<br>		<span class="hljs-keyword">break</span>；<span class="hljs-comment">//输入1,输出的结果是前三条java语句</span><br>	<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>		java语句;<br>		System.out.println(<span class="hljs-string">&quot;Test Code!&quot;</span>);<br>		<span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>6、所有分支都没有匹配成功，当有default的语句的话，会执行default分支当中的程序</strong></p>
<p><strong>7、switch后面和case后面只能是int或者String类型的数据，不能是探测其他类型。</strong></p>
<blockquote>
<ul>
<li>当然byte，short，char也可以直接写到switch和case后面，因为它们可以进行自动类型转换。byte，short，char可以自动转换成int类型。</li>
<li>JDK6的，switch和case后面只能探测int类型。</li>
<li>JDK7之后包括7版本在内，引入新特性，switch关键字和case关键字后面可以探测 int 和string类型的数据。</li>
</ul>
</blockquote>
<p><strong>8、case可以合并：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> i=<span class="hljs-number">10</span>；<br><span class="hljs-keyword">switch</span>（i）&#123;<br>	<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>：<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>：<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>： <span class="hljs-comment">//输入1、2、3输出的结果相同</span><br>		java语句;<br>		<span class="hljs-keyword">break</span>；<br>	<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>		java语句;<br>		System.out.println(<span class="hljs-string">&quot;Test Code!&quot;</span>);<br>		<span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>10、switch语句例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwitchTest01</span><br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">long</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10L</span>;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a; <span class="hljs-comment">//编译错误</span><br>		<br>		<span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">10L</span>;<br>		<span class="hljs-keyword">switch</span>(x)&#123;&#125; <span class="hljs-comment">//编译报错，switch语句不能用long</span><br>		<br>		解决编译错误:<br>		<span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">10L</span>;<br>		<span class="hljs-keyword">switch</span>((<span class="hljs-type">int</span>)x)&#123;&#125;<br>		<br>		<span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>		<span class="hljs-keyword">switch</span>(b)&#123;&#125; <span class="hljs-comment">//编译通过</span><br><br>		<span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>		<span class="hljs-keyword">switch</span>(s)&#123;&#125; <span class="hljs-comment">//编译通过</span><br>		<br>		<span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>		<span class="hljs-keyword">switch</span>(c)&#123;&#125; <span class="hljs-comment">//编译通过</span><br>		<br>		<span class="hljs-type">char</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br>		<span class="hljs-keyword">switch</span>(cc)&#123;&#125; <span class="hljs-comment">//编译通过</span><br>		<br>		 <span class="hljs-comment">//编译报错</span><br>		<span class="hljs-comment">//switch(ture)&#123;&#125;</span><br><br>		<span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>		<span class="hljs-keyword">switch</span>(username)&#123;&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>11、switch确实可以探测String类型，这是Java7的新特性。</strong></p>
<p><em><strong>简单计算器系统实现：</strong></em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwitchTest02</span>()<br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		java.util.<span class="hljs-type">Scanner</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Scanner(System.in);<br>		System.out.println(<span class="hljs-string">&quot;欢迎使用简单计算器系统：&quot;</span>);<br>		System.out.print(<span class="hljs-string">&quot;请输入第一个数字：&quot;</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> s.nextInt();<br>		System.out.print(<span class="hljs-string">&quot;请输入运算符&quot;</span>);<br>		<span class="hljs-type">String</span> <span class="hljs-variable">operator</span> <span class="hljs-operator">=</span> s.next();<br>		System.out.print(<span class="hljs-string">&quot;请输入第二个数字：&quot;</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> s.nextInt();<br><br>		<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">switch</span>(operator)&#123;<br>			<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span> :<br>				result = sum1 + sum2;<br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span> :<br>				result = sum1 - sum2;<br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span> :<br>				result = sum1 * sum2;<br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span> :<br>				result = sum1 / sum2;<br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;%&quot;</span> :<br>				result = sum1 % sum2;<br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">default</span> :<br>				System.out.println(<span class="hljs-string">&quot;输入运算符号错误&quot;</span>);<br>		&#125;	<br>		System.out.println(<span class="hljs-string">&quot;运算结果为：&quot;</span>+ num1 + operator + num2 + <span class="hljs-string">&quot;=&quot;</span> + result );<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>假设系统给定考生成绩，判断该考生的成绩等级：</p>
<blockquote>
<ul>
<li>有效成绩范围：【0-100】</li>
<li>考试成绩可以有小数</li>
<li>考试成绩和等级之间的对照关系：<br>【90-100】 A<br>【80-90】 B<br>【70-80】 C<br>【60-70】 D<br>【0-60】 E</li>
<li>以上需求必须采用switch语句完成，不能采用if<br>窍门：（int）(成绩 &#x2F; 10)</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwitchTest03</span>()<br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> 数字：<br>		<span class="hljs-type">int</span> <span class="hljs-variable">grade</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(score/<span class="hljs-number">10</span>);<br>		<span class="hljs-keyword">switch</span>(grade)&#123;<br>			<span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br>				System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>				System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<br>			<span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>				System.out.println(<span class="hljs-string">&quot;C&quot;</span>);<br>			<span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>				System.out.println(<span class="hljs-string">&quot;D&quot;</span>);<br>			<span class="hljs-keyword">default</span>:<br>				System.out.println(<span class="hljs-string">&quot;E&quot;</span>);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3、循环结构、for控制语句"><a href="#3、循环结构、for控制语句" class="headerlink" title="3、循环结构、for控制语句"></a>3、循环结构、for控制语句</h2><h3 id="1、循环结构"><a href="#1、循环结构" class="headerlink" title="1、循环结构"></a>1、循环结构</h3><p>在程序当中总有一些需要反复的执行的代码，假设没有循环结构，那么这段需要重复执行的代码自然是需要重复编写的。代码无法得到重复使用。所以多数编程语言都是支持循环结构的。将来把需要反复执行的代码片段放到“循环体”中，再联合“计数器”，共同控制这段需要反复执行的代码。</p>
<p><strong>基本上的所有编程语言支持的循环包括三种：</strong></p>
<blockquote>
<ul>
<li>for 循环</li>
<li>while 循环</li>
<li>do…while 循环</li>
</ul>
</blockquote>
<h3 id="2、for循环"><a href="#2、for循环" class="headerlink" title="2、for循环"></a>2、for循环</h3><p><strong>1 语法结构</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">for</span> (初始化表达式 ; 布尔表达式 ；更新表达式) &#123;<br> <br>循环体:由java语言构成，是需要重复执行的代码片段<br><br> &#125;<br></code></pre></td></tr></table></figure>

<p><strong>2 for循环的执行过程 &#x2F; 执行原理？</strong></p>
<p><strong>2.1 初始化表达式、布尔表达式、更新表达式不是必须的！【但是两个分号是必须的】</strong></p>
<p><strong>2.2 初始化表达式最先执行，并且在整个for循环当中只执行一次。</strong></p>
<p><strong>2.3 布尔表达式必须是true&#x2F;false，不能是其他值。</strong></p>
<p><strong>2.4 for的执行过程：</strong></p>
<blockquote>
<p>1、先执行初始化<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%A1%A8%E8%BE%BE%E5%BC%8F&spm=1001.2101.3001.7020">表达式</a>，并且该表达式只执行一次。</p>
</blockquote>
<blockquote>
<p>2、判断<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%B8%83%E5%B0%94&spm=1001.2101.3001.7020">布尔</a>表达式的结果是true还是false：</p>
<ul>
<li>布尔表达式为true：<br>1、执行循环体<br>2、执行更新表达式<br>3、判断布尔表达式的结果是true还是false<br>布尔表达式true<br>1、执行循环体<br>2、执行更新表达式<br>3、判断布尔表达式的结果是true还是false<br>…</li>
<li>布尔表达式为false<br>循环结束</li>
</ul>
</blockquote>
<p><strong>循环语句和条件判断语句嵌套使用【for和if的嵌套】</strong></p>
<blockquote>
<p><strong>找出1~100所有的奇数</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForTest01</span><br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		第一种方法<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i+=<span class="hljs-number">2</span>)&#123;<br>			System.out.println(<span class="hljs-string">&quot;奇数--&gt;&quot;</span> + i);<br>		&#125;<br>		<br>		第二种方法<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++)&#123;<br>			<span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br>				System.out.println(i)<br>			&#125; <br>		&#125;	<br>	&#125;<br>&#125;<br><span class="hljs-number">12345678910111213141516</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>求1~100所有奇数的和</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForTest02</span><br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i+=<span class="hljs-number">2</span>)&#123;<br>			sum+=i;<br>		&#125;<br>		System.out.println(<span class="hljs-string">&quot;sum=&quot;</span> + sum);<br>	&#125;<br></code></pre></td></tr></table></figure>

<p><strong>3 for循环也可以嵌套for循环</strong></p>
<blockquote>
<p>内层循环中的变量名和外层循环中的变量名不能重名</p>
</blockquote>
<p><strong>使用for循环输出九九乘法表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForTest03</span><br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>；i++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>				<span class="hljs-type">int</span>  a=i*j;<br>				System.out.print(i +<span class="hljs-string">&quot;*&quot;</span>+j+<span class="hljs-string">&quot;=&quot;</span>+a );<br>			&#125;<br>			System.out.println(); <span class="hljs-comment">//换行</span><br>			<span class="hljs-comment">//System.out.print(&quot;\n&quot;);</span><br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>编写for循环找出1~100中的所有素数</strong></p>
<blockquote>
<p><strong>素数：</strong> 又被称为质数，能够被1和自身整除，不能被其他数字整除的数字称为素数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForTest04</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">100</span>;i++)&#123;<br>            <span class="hljs-type">boolean</span> flag=<span class="hljs-literal">true</span>; <span class="hljs-comment">//标记i是否能被其他数整除</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;i;j++)&#123; <span class="hljs-comment">//此刻i只能被1和本身整除，所以应从2~i-1</span><br>                <span class="hljs-keyword">if</span>(i%j==<span class="hljs-number">0</span>)&#123; <br>                    flag=<span class="hljs-literal">false</span>;  <span class="hljs-comment">//如果i能被其他数整除，就跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (flag)<br>            System.out.print(i+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4、while控制语句、do…while控制语句、break、continue控制循环语句"><a href="#4、while控制语句、do…while控制语句、break、continue控制循环语句" class="headerlink" title="4、while控制语句、do…while控制语句、break、continue控制循环语句"></a>4、while控制语句、do…while控制语句、break、continue控制循环语句</h2><p><strong>1、while循环的语法结构</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">	<span class="hljs-keyword">while</span>（布尔表达式）&#123;<br>		循环体;<br>	&#125;<br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure>

<p><strong>2、while循环的执行原理：</strong></p>
<blockquote>
<p>判断<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%B8%83%E5%B0%94&spm=1001.2101.3001.7020">布尔</a>表达式的结果，如果结果为true就继续执行循环体，直到布尔表达式的结果为false，循环结束。</p>
</blockquote>
<p><strong>3、while循环的循环次数：：0~N次</strong></p>
<blockquote>
<p>注意：while循环的循环体可能执行次数为0次。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WhileTest01</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    	<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    	<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    	<span class="hljs-keyword">while</span>(i &gt;j)&#123;<br>    		System.out.println(<span class="hljs-string">&quot;死循环&quot;</span>);<br>    	&#125;<br>    	<span class="hljs-comment">//编译通过</span><br>    	System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    	<br>    	<span class="hljs-comment">//编译错误</span><br>    	<span class="hljs-comment">/*</span><br><span class="hljs-comment">    	while(10 &gt; 3)&#123;</span><br><span class="hljs-comment">    		System.out.println(&quot;死循环&quot;);</span><br><span class="hljs-comment">    	&#125;</span><br><span class="hljs-comment">    	*/</span><br>    	<br>    	<span class="hljs-comment">//编译错误：无法访问语句</span><br>    	<span class="hljs-comment">//System.out.println(&quot;Hello World!&quot;);</span><br>    	&#125;<br>    &#125;<br>&#125;<br><span class="hljs-number">1234567891011121314151617181920212223</span><br></code></pre></td></tr></table></figure>

<h3 id="1、do…while循环控制语句"><a href="#1、do…while循环控制语句" class="headerlink" title="1、do…while循环控制语句"></a>1、do…while循环控制语句</h3><p><strong>1、do…while循环的语法结构</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span>&#123;<br>	循环体;<br>&#125;<span class="hljs-keyword">while</span>(布尔表达式);<br></code></pre></td></tr></table></figure>

<p><strong>2、do…while循环的执行原理</strong></p>
<blockquote>
<p>先执行循环体，然后判断布尔表示是是否为true，true则执行，false则循环结束。</p>
</blockquote>
<p><strong>3、do…while循环的执行次数</strong></p>
<blockquote>
<p>do…while循环的循环体代码片段执行次数是：1~N次【至少一次】</p>
</blockquote>
<p><strong>4、使用do…while循环的注意事项</strong></p>
<blockquote>
<p>do…while<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5&spm=1001.2101.3001.7020">循环语句</a>最终有一个 <strong>“分号”</strong> 别丢了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoWhileTest</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br>		<span class="hljs-keyword">do</span>&#123;<br>			System.out.println(i);<br>		&#125;<span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">100</span>);  <span class="hljs-comment">//输出10，先执行在进行判断</span><br><br>		<span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">100</span>)&#123;<br>			System.out.println(<span class="hljs-string">&quot;i--&gt;&quot;</span>+i);<br>		&#125; <span class="hljs-comment">//无输出</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2、break控制语句"><a href="#2、break控制语句" class="headerlink" title="2、break控制语句"></a>2、break控制语句</h3><blockquote>
<ul>
<li>break是java语言当中的关键字，被翻译为“中断&#x2F;折断”。</li>
<li>break + “;”可以成为一个单独的完整的java语句： <strong>break；</strong></li>
<li>break语句使用在switch语句当中，用来终止switch的语句执行。</li>
<li>break语句同样可以使用在循环语句当中，用来终止循环的执行。</li>
<li>break终止哪个循环呢？</li>
<li>break；语句使用在for、while、do…while循环语句当中用来跳出循环，终止循环的执行。因为当程序循环到某个条件时，后续的循环就没必要执行了，在执行也是耗费资源，所以可以终止循环，这样可以提高程序的执行效率。</li>
<li>在默认情况下：break语句终止的是离它最近的循环语句。</li>
<li>当然也可以指定终止某个循环，需要给循环起名，采用这种语法： <strong>break 循环名称;</strong></li>
</ul>
</blockquote>
<p>以下以for循环为例解释 <strong>break；</strong> 语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BreakTest</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>			<span class="hljs-keyword">if</span>(i==<span class="hljs-number">5</span>)<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>			System.out.println(i); <span class="hljs-comment">//0 1 2 3 4</span><br><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;j++)&#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>				<span class="hljs-keyword">if</span>(i==<span class="hljs-number">5</span>)<br>				<span class="hljs-keyword">break</span>;<span class="hljs-comment">//这里的break语句终止的是内层for循环，因为这个for离它最近。</span><br>				<span class="hljs-comment">//这里的break语句不会影响到外层的for循环</span><br>			&#125;<br>				System.out.println(i); <span class="hljs-comment">//0 1 2 3 4    0 1 2 3 4      0 1 2 3 4</span><br>		&#125;<br>		<br>		<span class="hljs-comment">//给for循环起名</span><br>		for1:<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;j++)&#123;<br>			for2:<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>				<span class="hljs-keyword">if</span>(i==<span class="hljs-number">5</span>)&#123;<br>					<span class="hljs-keyword">break</span> for1;<span class="hljs-comment">//终止for1循环</span><br>				&#125;<br>				System.out.println(i); <span class="hljs-comment">//0 1 2 3 4  </span><br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3、continue控制语句"><a href="#3、continue控制语句" class="headerlink" title="3、continue控制语句"></a>3、continue控制语句</h3><p><strong>1、continue表示：继续&#x2F;go on&#x2F; 下一个</strong></p>
<p><strong>2、continue也是一个continue关键字加一个分号构成一个单独的完整的java语句，主要出现循环语句当中用来控制循环的执行。</strong></p>
<p><strong>3、break和continue的区别：</strong></p>
<blockquote>
<ul>
<li>break表示循环不执行了。</li>
<li>continue表示直接进入下一次循环继续执行。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContinueTest</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>			<span class="hljs-keyword">if</span>(i==<span class="hljs-number">5</span>)<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>			System.out.println(i); <span class="hljs-comment">//0 1 2 3 4</span><br><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>			<span class="hljs-keyword">if</span>(i==<span class="hljs-number">5</span>)<br>			<span class="hljs-keyword">continue</span>; <span class="hljs-comment">//只要这个语句执行，当前本次循环停止，直接进入下一次循环“继续”执行</span><br>		&#125;<br>			System.out.println(i); <span class="hljs-comment">//0 1 2 3 4 6 7 8 9</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>4、continue也有这样的语法：</strong></p>
<blockquote>
<p><strong>continue 循环名称;</strong></p>
</blockquote>
<h1 id="四、构造方法"><a href="#四、构造方法" class="headerlink" title="四、构造方法"></a>四、构造方法</h1><h2 id="1、方法的基础知识、语法及含义、方法调用规则"><a href="#1、方法的基础知识、语法及含义、方法调用规则" class="headerlink" title="1、方法的基础知识、语法及含义、方法调用规则"></a>1、方法的基础知识、语法及含义、方法调用规则</h2><h3 id="1、方法"><a href="#1、方法" class="headerlink" title="1、方法"></a>1、方法</h3><blockquote>
<p>在Java语言当中应该有这样一个机制：</p>
<ul>
<li>某个功能代码只需要写一遍</li>
<li>要使用这个功能，只需要给这个功能传递具体的数据</li>
<li>这个功能完成之后返回一个最终的结果。</li>
</ul>
<p>这样代码就可以重复使用了，提高代码的复用性。【这就是 <strong>“方法”</strong> 】</p>
</blockquote>
<blockquote>
<p>使用这个<strong>方法</strong>我们称为 <strong>“调用&#x2F;invoke”</strong></p>
</blockquote>
<h3 id="2、方法的本质"><a href="#2、方法的本质" class="headerlink" title="2、方法的本质"></a>2、方法的本质</h3><blockquote>
<p>方法就是一段代码片段，并且这段代码片段可以完成某个特定的功能，并且可以被重复使用。<br>方法，对应的英语单词：Method，在C语言中叫做函数：Function、</p>
</blockquote>
<blockquote>
<p>方法定义在类体中，在一个类当中可以定义多个方法，方法编写的位置没有先后顺序，可以随意。</p>
</blockquote>
<blockquote>
<p><strong>方法体中不能再定义方法！！！！！！</strong></p>
</blockquote>
<h3 id="3、方法的基础语法"><a href="#3、方法的基础语法" class="headerlink" title="3、方法的基础语法"></a>3、方法的基础语法</h3><h4 id="1、语法结构"><a href="#1、语法结构" class="headerlink" title="1、语法结构"></a>1、语法结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[修饰符列表] 返回值类型 方法名(形式参数列表)&#123;<br>	方法体;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2、对以上语法结构进行解释说明："><a href="#2、对以上语法结构进行解释说明：" class="headerlink" title="2、对以上语法结构进行解释说明："></a>2、对以上语法结构进行解释说明：</h4><h5 id="2-1-关于修饰符列表"><a href="#2-1-关于修饰符列表" class="headerlink" title="2.1 关于修饰符列表"></a>2.1 关于修饰符列表</h5><blockquote>
<ul>
<li>可选项，不是必须的</li>
<li>目前统一写成public static</li>
<li>方法的修饰符列表当中”有static关键字”的话，怎么调用这个方法？<br><strong>类名.方法名(实际参数列表);</strong></li>
</ul>
</blockquote>
<h5 id="2-2-返回值类型"><a href="#2-2-返回值类型" class="headerlink" title="2.2 返回值类型"></a>2.2 返回值类型</h5><blockquote>
<p><strong>1、什么是返回值？</strong></p>
<ul>
<li>一个方法是可以完成某个特定功能的，这个功能结束之后大多数都是需要返回最终执行结果的，执行结果可能是一个具体存在的数据。而这个具体存在的数据就是返回值。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>2、返回值类型？</strong></p>
<ul>
<li>返回值就是一个具体存在的数据，数据都是有类型的，此处需要指定的是返回值的具体类型。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>3、返回值类型都可以指定哪些类型呢？</strong></p>
<ul>
<li>java任意一种类型都可以，包括基本数据类型和所有的引用数据类型。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>4、也可能这个方法执行结束之后不返回任何数据，java中规定，当一个方法执行结束之后不返回任何数据的话，返回值类型位置必须编写：*void 关键字*。</strong></p>
</blockquote>
<blockquote>
<p><strong>5、返回值类型可以是：</strong></p>
<ul>
<li>byte，short，int，long，float，double，boolean，char，string，void…</li>
</ul>
</blockquote>
<blockquote>
<p>6、返回值类型若不是 void，表示这个方法执行结束之后必须返回一个具体的数值。当方法执行结束的时候，没有返回任何数据的话，编译器报错。怎么返回值呢？代码怎么写呢？“<strong>return 值;</strong>”并且要求“值”的数据类型必须和“方法的返回值类型”一致，不然编译器报错。</p>
</blockquote>
<blockquote>
<p>7、返回类型是void的时候，在方法体当中不能编写“<strong>return 值；</strong>”这样的语句。但是要注意可以编写“<strong>return；</strong>”这样的语句。</p>
</blockquote>
<blockquote>
<p>8、只要带有关键字的语句执行，return语句所在的方法结束。【不是JVM结束，是return所在的方法结束】</p>
</blockquote>
<h5 id="2-3-方法名"><a href="#2-3-方法名" class="headerlink" title="2.3 方法名"></a>2.3 方法名</h5><blockquote>
<ul>
<li>只要是合法的标识符就行</li>
<li>方法名最好见名知意</li>
<li>方法名最好是动词</li>
<li>方法名首字母要求是小写，后面每个单词首字母大写</li>
</ul>
</blockquote>
<h5 id="2-4-形式参数列表：简称形参"><a href="#2-4-形式参数列表：简称形参" class="headerlink" title="2.4 形式参数列表：简称形参"></a>2.4 形式参数列表：简称形参</h5><blockquote>
<ul>
<li>形参是局部变量：int a；double b；…</li>
<li>形参的个数可以是0~N个</li>
<li>多个形参之间用“逗号”隔开</li>
<li>形参中起决定性作用的是形参的数据类型，形参的名字就是局部变量的名字。</li>
<li>方法在调用的时候，实际给这个方法传递的真实数据被称为：实际参数，简称实参</li>
<li>实参列表和形参列表必须满足：<br>1 数量相同<br>2 类型对应相同</li>
<li></li>
</ul>
</blockquote>
<h5 id="2-5-方法体必须由大括号括起来，方法体中的代码有顺序"><a href="#2-5-方法体必须由大括号括起来，方法体中的代码有顺序" class="headerlink" title="2.5 方法体必须由大括号括起来，方法体中的代码有顺序"></a>2.5 方法体必须由大括号括起来，方法体中的代码有顺序</h5><p><strong>实例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//public表示公开的</span><br><span class="hljs-comment">//class表示定义类</span><br><span class="hljs-comment">//MethodTest是一个类名</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodTest</span>&#123; <span class="hljs-comment">//表示定义一个公开的类，起名MethodTest，由于是公开的类，所以源文件名必须为：MethodTest</span><br>	<span class="hljs-comment">//类体</span><br>	<span class="hljs-comment">//类体中不能出现直接编写java语句，除声明变量之外</span><br>	<span class="hljs-comment">//方法出现在类体当中</span><br><br>	<span class="hljs-comment">//方法</span><br>	<span class="hljs-comment">//public表示公开的</span><br>	<span class="hljs-comment">//static表示静态的</span><br>	<span class="hljs-comment">//void表示方法执行结束后不返回任何数据</span><br>	<span class="hljs-comment">//main是方法名：主方法</span><br>	<span class="hljs-comment">//(String[] args)：形式参数列表，其中String[]是一种引用数据类型，args是一个局部变量的变量名</span><br>	<span class="hljs-comment">//所以以下只有args这个局部变量的变量名是随意的</span><br>	<span class="hljs-comment">//主方法就需要这样固定编写，这是程序的入口。【SUN公司规定的，必须这样写】</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><br>	<span class="hljs-comment">//这里的程序是一定会执行的</span><br>	<span class="hljs-comment">//main方法是JVM负责调用的，是一个入口的位置</span><br>	<span class="hljs-comment">//从这里作为起点开始执行程序</span><br>	<span class="hljs-comment">//既然是这样，我们就可以在这里编写java语句来调用其他方法</span><br>	<span class="hljs-comment">//调用MethodTest的sum方法，传递两个实参</span><br>	MethodTest.sum(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<span class="hljs-comment">//(10,20)实参列表</span><br><br>	<span class="hljs-comment">//注意：方法体当中的代码是有顺序的，遵循自上而下的顺序以此执行</span><br>	<span class="hljs-comment">//上一行代码的程序执行不结束，无法执行下一行代码。	</span><br>	<br>	<span class="hljs-comment">//一个方法可以被重复使用，重复调用</span><br>	<span class="hljs-type">int</span> a=<span class="hljs-number">100</span>;<br>	MethodTest.sum(a,<span class="hljs-number">500</span>);<span class="hljs-comment">// (a,500)实参列表</span><br><br>	<span class="hljs-comment">//再次调用方法</span><br>	<span class="hljs-type">int</span> k=<span class="hljs-number">90</span>;<br>	<span class="hljs-type">int</span> f=<span class="hljs-number">10</span>;<br>	MethodTest.sum(k,f);<span class="hljs-comment">//(k,f)实参列表</span><br>	&#125;<br><br>	<span class="hljs-comment">//自定义方法，不是程序的入口</span><br>	<span class="hljs-comment">//方法的作用：计算两个int类型数据的和，不要求返回结果，但是要求将结果直接输出到控制台</span><br>	<span class="hljs-comment">//修饰符列表：public static</span><br>	<span class="hljs-comment">//返回值类型：void</span><br>	<span class="hljs-comment">//方法名：sum</span><br>	<span class="hljs-comment">//形式参数列表：(int x，int y)</span><br>	<span class="hljs-comment">//方法体：主要任务是求和之后输出计算结果</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;<br>		System.out.println(x+<span class="hljs-string">&#x27;+&#x27;</span>+ y +<span class="hljs-string">&#x27;=&#x27;</span>+ (x+y))<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3、方法怎么调用？"><a href="#3、方法怎么调用？" class="headerlink" title="3、方法怎么调用？"></a>3、方法怎么调用？</h4><p>方法只定义不去调用是不会执行的，只有在调用的时候才会执行。<br><strong>语法规则：</strong>《方法的修饰符列表当中有static》</p>
<blockquote>
<ul>
<li><strong>类名.方法名(实参列表)；</strong>&lt;这是一条java语句，表示调用某个类的某个方法，传递这样的实参。&gt;</li>
</ul>
</blockquote>
<h2 id="2、java的方法调用、调用的实参与形参类型、方法返回值类型不是void、深入return语句"><a href="#2、java的方法调用、调用的实参与形参类型、方法返回值类型不是void、深入return语句" class="headerlink" title="2、java的方法调用、调用的实参与形参类型、方法返回值类型不是void、深入return语句"></a>2、java的方法调用、调用的实参与形参类型、方法返回值类型不是void、深入return语句</h2><h3 id="1、Java语言的方法"><a href="#1、Java语言的方法" class="headerlink" title="1、Java语言的方法"></a>1、Java语言的方法</h3><p><strong>实例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodTest01</span>()&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>		System.out.println(a+<span class="hljs-string">&quot;+&quot;</span>+b+<span class="hljs-string">&quot;=&quot;</span>+(a+b));<br>		<span class="hljs-comment">//调用doSome方法</span><br>		MethodTest.doSome();<br>	&#125;<br>	<span class="hljs-comment">//主方法</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-comment">//调用sum方法</span><br>		MethodTest.sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSome</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;do some!&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>以上代码了看出：方法的调用不一定在main方法当中。只要是程序可以执行到的位置，都可以调用其他的方法。</strong></p>
<h4 id="1、方法调用的时候实参和形参要求个数对应相同，数据类型对应相同。"><a href="#1、方法调用的时候实参和形参要求个数对应相同，数据类型对应相同。" class="headerlink" title="1、方法调用的时候实参和形参要求个数对应相同，数据类型对应相同。"></a>1、方法调用的时候实参和形参要求个数对应相同，数据类型对应相同。</h4><p><strong>类型不同的时候要求能够进行相应的自动类型转换</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodTest02</span>()&#123;<br>	<span class="hljs-comment">//主方法</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		MethodTest02.sum();<span class="hljs-comment">//编译错误：参数数量不同</span><br>		MethodTest02.sum(<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>);<span class="hljs-comment">//编译错误：实参和形参的类型不是对应相同的</span><br>		MethodTest02.sum(<span class="hljs-number">10L</span>,<span class="hljs-number">20L</span>);<span class="hljs-comment">//编译通过</span><br>		MethodTest02.sum(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<span class="hljs-comment">//编译通过：存在自动类型转换：int--&gt;long</span><br>		MethodTest02.sum(<span class="hljs-number">3.0</span>,<span class="hljs-number">20</span>);<span class="hljs-comment">//编译错误：参数类型不是对应相同的</span><br>		MethodTest02.sum((<span class="hljs-type">long</span>)<span class="hljs-number">3.0</span>,<span class="hljs-number">20</span>);<span class="hljs-comment">//编译通过</span><br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">long</span> a,<span class="hljs-type">long</span> b)</span>&#123;<br>		System.out.println(a+<span class="hljs-string">&quot;+&quot;</span>+b+<span class="hljs-string">&quot;=&quot;</span>+(a+b));<br><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2、方法调用"><a href="#2、方法调用" class="headerlink" title="2、方法调用"></a>2、方法调用</h3><blockquote>
<p>1、方法的修饰符列表当中有<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020">static</a>关键字，完整的调用方法是：<strong>类名 . 方法名（实参列表）</strong><br>2、但是，有时候 <strong>“ 类名.”</strong> 可以省略，什么情况下可以省略呢？</p>
<ul>
<li>对于方法的<strong>修饰符列表</strong>当中有<strong>static关键字</strong>的：<strong>“类名.”</strong> 可以省略不写。</li>
<li>调用<strong>同个类</strong>中的方法可省略不写</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodTest03</span>()&#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;main begin&quot;</span>);<br>		m1();<br>		System.out.println(<span class="hljs-string">&quot;main over&quot;</span>);<br>		&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;m1 begin&quot;</span>);<br>		m2();<br>		System.out.println(<span class="hljs-string">&quot;m2 over&quot;</span>);<br>		&#125;<br>		<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;m2 begin&quot;</span>);<br>		m3();<br>		System.out.println(<span class="hljs-string">&quot;m2 over&quot;</span>);<br>		&#125;<br>		<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;m3 begin&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;m3 over&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>输出结果：</strong><br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/99a43e292e2a680f925b6363d7a934b4-1741868481336-89.png" srcset="/img/loading.gif" lazyload alt="输出结果"></p>
<blockquote>
<p><strong>方法中的代码是自上而下的顺序依次执行的</strong></p>
</blockquote>
<h4 id="1、方法的返回值类型不是void的时候"><a href="#1、方法的返回值类型不是void的时候" class="headerlink" title="1、方法的返回值类型不是void的时候"></a>1、方法的返回值类型不是void的时候</h4><blockquote>
<ul>
<li>返回值类型不是void的时候：要求方法必须保证百分百的执行“return 值；”这样的语句来完成值的返回。没有这个语句编译器会报错。</li>
<li>一个方法有返回值的时候，当我们调用这个方法的时候，方法返回了一个值，对于调用者来说，这个返回值可以选择接收，也可以选择不接收。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodTest04</span>()&#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-comment">//调用方法</span><br>		divide(<span class="hljs-number">10</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//这里没有接收这个方法的返回数据</span><br>		<br>		<span class="hljs-comment">//这里接收返回值</span><br>		<span class="hljs-comment">//采用变量接收</span><br>		<span class="hljs-comment">//变量的数据类型需要和返回值的数据类型相同，或者可以自动类型转换</span><br>		<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> divide(<span class="hljs-number">10</span>,<span class="hljs-number">3</span>);<br>	&#125;<br>	<br>`	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	需求：</span><br><span class="hljs-comment">		请定义并实现一个方法，该方法可以计算两个int类型数据的商，</span><br><span class="hljs-comment">		要求将最终计算结果返回给调用者。</span><br><span class="hljs-comment">	*/</span><br><br>	<span class="hljs-comment">//编译错误：缺少返回值</span><br>	<span class="hljs-comment">/*public static int divide(int a, int b)&#123;</span><br><span class="hljs-comment">		return;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	//编译错误：方法定义的时候要求返回一个int类型，此时返回布尔类型，类型不兼容</span><br><span class="hljs-comment">	public static int divide(int a, int b)&#123;</span><br><span class="hljs-comment">		return true;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	//可以：但是具体方法体中编写的代码无法满足当前的需求</span><br><span class="hljs-comment">	public static int divide(int a, int b)&#123;</span><br><span class="hljs-comment">		return 1;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">	public static int divide(int a, int b)&#123;</span><br><span class="hljs-comment">		int c=a/b;</span><br><span class="hljs-comment">		return c;</span><br><span class="hljs-comment">	&#125;*/</span><br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>		<span class="hljs-keyword">return</span> a/b;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2、深入return语句"><a href="#2、深入return语句" class="headerlink" title="2、深入return语句"></a>2、深入return语句</h4><blockquote>
<ul>
<li>带有return关键字的java语句只要执行，所在的方法执行结束。</li>
<li>在“同一个作用域”当中，return语句下面不能编写任何代码，因为这些代码永远都执行不到，所以编译报错。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodTest05</span>()&#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">int</span> reValue=m();<br>		System.out,println(reValue);<br>	&#125;<br>	<br>	<span class="hljs-comment">//编译报错：缺少返回语句，以下程序编译器认为无法百分百保证“return 1；”会执行</span><br>	<span class="hljs-comment">/*public static int m()&#123;</span><br><span class="hljs-comment">		int a=10;</span><br><span class="hljs-comment">		if(a&gt;3)&#123;</span><br><span class="hljs-comment">			return 1;</span><br><span class="hljs-comment">		&#125;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">	*/</span><br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">m</span><span class="hljs-params">()</span>&#123;<br>		<span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>		<span class="hljs-keyword">if</span>(a&gt;<span class="hljs-number">3</span>)&#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>			<span class="hljs-comment">//这里不能编写代码，编译错误，因为无法执行访问的语句</span><br>			<span class="hljs-comment">//System.out.println(&quot;Hello&quot;);</span><br>		&#125;<br>		<span class="hljs-comment">//这里的代码可以执行</span><br>		System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>在返回值类型是void的方法当中使用“return；”语句。“return；”语句当中出现在返回值为void的方法当中主要是为了终止方法的执行。</strong></p>
<blockquote>
<p>return；直接终止方法；break只是终止循环。<br>return更强</p>
</blockquote>
<h2 id="3、方法执行JVM内存分析"><a href="#3、方法执行JVM内存分析" class="headerlink" title="3、方法执行JVM内存分析"></a>3、方法执行JVM内存分析</h2><h3 id="1、方法在执行过程当中，在JVM中的内存是如何分配的呢，内存是如何变化的？"><a href="#1、方法在执行过程当中，在JVM中的内存是如何分配的呢，内存是如何变化的？" class="headerlink" title="1、方法在执行过程当中，在JVM中的内存是如何分配的呢，内存是如何变化的？"></a>1、方法在执行过程当中，在JVM中的内存是如何分配的呢，内存是如何变化的？</h3><blockquote>
<ul>
<li><strong>方法只定义，不调用，是不会执行的，并且在JVM中也不会给该方法分配“运行所属”的内存空间。只有在调用这个方法的时候，才会动态的给这个方法分配所属的空间</strong>。</li>
<li><strong>在JVM内存划分上有这样三块主要的内存空间：</strong><br>1、方法区内存<br>2、堆内存<br>3、栈内存</li>
<li><strong>关于栈数据结构</strong>：<br>1、栈：stack，是一种数据结构<br>2、数据结构反应的是数据的存储形态。<br>3、数据结构是独立的学科，不属于任何编程语言的范畴，只不过在大多数编程语言当中要使用数据结构。<br>4、作为程序员需要提前精通：数据结构+算法【计算机专业必修的一门语言】<br>5、常见的数据结构：数组、队列、栈、链表、二叉树、哈希表…</li>
<li><strong>方法代码片段存在哪里？方法执行的时候执行过程的内存在哪里分配？</strong><br>1、方法片段属于.class字节码文件的一部分，字节码文件在类加载的时候，将其放到了方法区当中。所以JVM中的三块主要的内存空间中的方法区内存最先有数据，存放了代码片段。<br>2、代码片段虽然在方法区内存当中只有一份，但是可以被重复调用。每一次调用这个方法的时候，需要给该方法分配独立的活动场所，在栈内存中分配。【栈内存中分配方法运行的所属空间】</li>
<li><strong>方法在调用的时候，会给该方法分配独立的内存空间，在栈中分配，此时发生压栈动作，方法执行结束之后，给该方法分配的内存空间全部释放，此时发生弹栈动作。</strong><br>压栈：给方法分配内存。<br>弹栈：释放该方法的内存空间。</li>
<li><strong>局部变量在栈中存储。局部变量在运行阶段内存在栈中分配。</strong></li>
</ul>
</blockquote>
<p><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/a0e60c306f4ab808af5b6e0c97d3642e-1741868481336-90.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><strong>栈内存:</strong><br>1） 是为java方法提供运行空间的<br>2） 方法一旦被调用就会在栈中创建对应的栈帧，而方法的整个执行过程就是方法对应的栈帧从入栈到出栈的过程。换言之，就是方法被调用进栈（压栈 入栈），方法执行结束出栈（弹栈）。<br>3） 栈是先进后出后进先出（先被调用的方法最后结束，后被调用的方法最先结束）<br>4） 栈中的变量都是属于方法的，所以都是<strong>局部变量</strong>，且<strong>局部变量必须初始化值</strong>。<br>5） 栈生命周期与其所属线程的生命周期一致，可以认为栈具有自动销毁机制。</p>
<p><strong>堆内存:</strong><br>1） 是为实体对象来开辟空间的，换言之就是实体对象的空间都在堆中开辟。凡是被new出来的都是对象。<br>2） 堆中的变量是对象变量，因为是属于对象的，且是随着对象的创建而产生随着对象的销毁而销毁。<br>3） 堆中的变量（对象变量）都有默认值：</p>
<blockquote>
<ul>
<li>整数：0</li>
<li>浮点型：0.0</li>
<li>布尔型：false</li>
<li>char型：’ ’</li>
<li>对象：null</li>
</ul>
</blockquote>
<p>4） 堆没有自动销毁机制，它里面的垃圾由垃圾回收器负责收集（通过收集算法判断哪个对象属于垃圾然后再清理）<br>5） 堆中的空间都有一个16进制的首地址作为地址进行区分。</p>
<p><strong>方法区:</strong><br>方法区中存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>常量是存放在方法区中的运行时常量池中的。</p>
<p><strong>重点：方法调用的时候，在参数传递的时候，实际上传递得是变量中保存的那个“值”传过去了。</strong></p>
<h2 id="4、方法重载机制overload、方法递归"><a href="#4、方法重载机制overload、方法递归" class="headerlink" title="4、方法重载机制overload、方法递归"></a>4、方法重载机制overload、方法递归</h2><h3 id="1、方法重载-overload"><a href="#1、方法重载-overload" class="headerlink" title="1、方法重载(overload)"></a>1、方法重载(overload)</h3><blockquote>
<ul>
<li>功能虽然不同，但是“功能相似”的时候，方法重载机制可以让相似的方法就像在用一个方法一样。【Java支持这种机制而有些语言则不支持，例如JavaScript】</li>
<li><strong>功能相似的时候，方法名可以相同。</strong></li>
</ul>
</blockquote>
<h4 id="1、什么时候考虑使用方法重载？"><a href="#1、什么时候考虑使用方法重载？" class="headerlink" title="1、什么时候考虑使用方法重载？"></a>1、什么时候考虑使用方法重载？</h4><ul>
<li>功能相似的时候，尽可能让方法名相同【但是功能不同&#x2F;不相似的时候，尽可能让方法名不同】</li>
</ul>
<h4 id="2、什么条件满足之后构成了方法重载"><a href="#2、什么条件满足之后构成了方法重载" class="headerlink" title="2、什么条件满足之后构成了方法重载"></a>2、什么条件满足之后构成了方法重载</h4><ul>
<li>在同一个类当中</li>
<li>方法名相同</li>
<li>参数列表不同：<br>1、数量不同:<code>public static void m1()&#123;&#125; 与 public static void m1(int a)&#123;&#125;</code><br>2、顺序不同: <code>public static void m2(int a,double b)&#123;&#125; 与 public static void m2(double a,int b)&#123;&#125;</code><br>3、类型不同:<code>public static void m3(int x)&#123;&#125; 与 public static void m3(double x)&#123;&#125;</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">方法重复，编译错误。<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m4</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;&#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m4</span><span class="hljs-params">(<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> a)</span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3、方法重载和什么有关系，和什么没有关系"><a href="#3、方法重载和什么有关系，和什么没有关系" class="headerlink" title="3、方法重载和什么有关系，和什么没有关系"></a>3、方法重载和什么有关系，和什么没有关系</h4><ul>
<li>方法重载和方法名+参数列表有关系</li>
<li>方法重载和返回值类型无关</li>
<li>方法重载和修饰符列表无关</li>
</ul>
<h3 id="2、方法递归"><a href="#2、方法递归" class="headerlink" title="2、方法递归"></a>2、方法递归</h3><ul>
<li><strong>什么是递归？</strong><br>即：方法自身调用自身。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">a()&#123;<br>	a();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>递归是很耗栈内存的，递归算法可以不用的时候尽量别用。</strong></li>
<li><strong>以下程序运行的时候发生这样的一个错误</strong>【不是异常，是错误error】：<br>java.lang.StackOverflowError<br>栈内存溢出错误<br>错误发生无法晚挽回，只有一个结果。就是JVM停止工作。</li>
<li><strong>递归必须有结束条件，没有结束条件一定会发生栈内存溢出错误。</strong></li>
<li><strong>递归即使有了结束条件，即便结束条件是正确的，也可能会发生栈内存溢出错误，因为递归太深了。</strong></li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>递归可以不使用尽量别用。</li>
<li>但是有些情况下该功能的实现必须依靠递归方式。</li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//递归计算前n个数的和：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursionTest01</span>&#123;<br>	publci <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">int</span> n=<span class="hljs-number">4</span>;<br>		<span class="hljs-type">int</span> reValue=sum(n);<br>		System.out.println(reValue);<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>		<span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>		&#125;<br>		<span class="hljs-keyword">return</span> n+sum(n-<span class="hljs-number">1</span>);	<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//递归计算n的阶乘：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursionTest02</span>&#123;<br>	publci <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">int</span> n=<span class="hljs-number">5</span>;<br>		<span class="hljs-type">int</span> reValue=method(n);<br>		System.out.println(reValue);<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>		<span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>		&#125;<br>		<span class="hljs-keyword">return</span> n*method(n-<span class="hljs-number">1</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="五、面向对象及封装"><a href="#五、面向对象及封装" class="headerlink" title="五、面向对象及封装"></a>五、面向对象及封装</h2><h2 id="1、面向对象和面向过程的区别、面向对象、类和对象概念、类的定义"><a href="#1、面向对象和面向过程的区别、面向对象、类和对象概念、类的定义" class="headerlink" title="1、面向对象和面向过程的区别、面向对象、类和对象概念、类的定义"></a>1、面向对象和面向过程的区别、面向对象、类和对象概念、类的定义</h2><h3 id="1、面向对象和面向过程的区别"><a href="#1、面向对象和面向过程的区别" class="headerlink" title="1、面向对象和面向过程的区别"></a>1、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1&spm=1001.2101.3001.7020">面向对象</a>和面向过程的区别</h3><ul>
<li><strong>面向过程：</strong> 主要关注点是：实现的具体过程，因果关系【集成显卡的开发思路】<br><strong>优点：</strong> 对于业务逻辑比较简单的程序，可以达到快速开发，前期投入成本较低。<br><strong>缺点：</strong> 采用面向过程的方式开发很难解决非常复杂的业务逻辑，另外面向过程的方式导致软件元素之间“耦合度”非常高，只要其中一环出现了问题，整个系统受到影响，导致最终的软件扩展力差。另外，由于没有独立体的概念，所以无法达到组件复用。</li>
<li><strong>面向对象：</strong> 主要关注点是：主要关注对象【独立体】能完成哪些功能。【独立显卡的开发思路】<br><strong>优点：</strong> 耦合度低，扩展能力强。更容易解决现实世界当中更复杂的业务逻辑，组件复用性强。<br><strong>缺点：</strong> 前期投入成本高，需要进行独立体的抽取，大量的系统分析与设计。</li>
</ul>
<blockquote>
<ul>
<li>C语言是纯面向过程的，C++半面向对象、Java纯面向对象</li>
</ul>
</blockquote>
<h3 id="2、面向对象的三大特征"><a href="#2、面向对象的三大特征" class="headerlink" title="2、面向对象的三大特征"></a>2、面向对象的三大特征</h3><ul>
<li><strong>封装</strong></li>
<li><strong>继承</strong></li>
<li><strong>多态</strong></li>
</ul>
<p>注：所有面向对象的编程语言都有这三大特征。</p>
<p><strong>采用面向对象的方式开发一个软件</strong>，生命周期当中：【整个生命周期中贯穿使用OO面向对象方式】</p>
<ul>
<li>面向对象的分析：OOA</li>
<li>面向对象的设计：OOD</li>
<li>面向对象的编程：OOP</li>
</ul>
<h3 id="3、类的对象的概念"><a href="#3、类的对象的概念" class="headerlink" title="3、类的对象的概念"></a>3、类的对象的概念</h3><h4 id="1、什么是类？"><a href="#1、什么是类？" class="headerlink" title="1、什么是类？"></a>1、什么是类？</h4><ul>
<li>类在现实世界当中是不存在的，是一个模板，是一个概念。是人类大脑思考抽象的结果。</li>
<li>类代表了一种事物。</li>
<li>在现实世界中，对象A与对象B之间具有共同特征，进行抽象总结出一个模板，这个模板被称为类。</li>
</ul>
<h4 id="2、什么是对象？"><a href="#2、什么是对象？" class="headerlink" title="2、什么是对象？"></a>2、什么是对象？</h4><ul>
<li>对象是实际存在的个体。现实世界当中实际存在。</li>
</ul>
<h4 id="4、软件开发的过程："><a href="#4、软件开发的过程：" class="headerlink" title="4、软件开发的过程："></a>4、软件开发的过程：</h4><ul>
<li>程序员先观察现实世界，从现实世界当中寻找对象</li>
<li>寻找了N个对象之后，发现所有的对象都有共同特征</li>
<li>程序员在大脑中形成一个模板【类】</li>
<li>Java程序员可以通过java代码来表述这个类</li>
<li>Java程序中有了类的定义</li>
<li>然后通过类就可以创建对象</li>
<li>有了对象之后，可以让对象直接协作起来形成一个系统。</li>
</ul>
<p><strong>类–【实例化】-&gt;对象</strong></p>
<p><strong>对象又被称为实例&#x2F;instance</strong></p>
<p><strong>对象–【抽象】–&gt;类</strong></p>
<p><strong>重点：</strong></p>
<ul>
<li>类描述的是对象的共同特征。</li>
<li>共同特征例如：身高特征<br>这个身高特征在访问的时候，必须先创建对象，通过对象去访问这个特征。因为这个特征具体的某个对象上之后，值不同。有的对象身高1.80，有的对象身高2.80.</li>
</ul>
<h4 id="5、一个类主要描述什么信息呢？"><a href="#5、一个类主要描述什么信息呢？" class="headerlink" title="5、一个类主要描述什么信息呢？"></a>5、一个类主要描述什么信息呢？</h4><p>一个类主要描述的是：<strong>状态+动作</strong>。<br>状态信息：名字、身高、性别、年龄<br>动作信息：吃、喝、玩、乐</p>
<ul>
<li>状态–&gt;一个类的属性</li>
<li>动作–&gt;一个类的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">类&#123;<br>	属性; <span class="hljs-comment">//描述对象的状态信息</span><br>	方法; <span class="hljs-comment">//描述对象的动作信息</span><br>	&#125;<br></code></pre></td></tr></table></figure>

<p>注意：状态和动作当具体到某个对象上之后，发现最终的结果可能不一样。</p>
<h2 id="4、类的定义【开始编写代码】"><a href="#4、类的定义【开始编写代码】" class="headerlink" title="4、类的定义【开始编写代码】"></a>4、类的定义【开始编写代码】</h2><p><strong>语法结构：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">[修饰符列表] class 类名&#123;<br>	属性；<br>	方法；<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>重点：属性通常是采用一个变量的形式来完成定义的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">定义一个类，类名Student<br>Student是一个类。代表了所有的学生对象，是一个学生模板<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<span class="hljs-comment">//定义一个公开的类</span><br><br><span class="hljs-comment">//属性【描述的是对象的状态信息】</span><br><span class="hljs-comment">//属性通常采用变量的方式来定义</span><br><span class="hljs-comment">//在类体当中，方法体之外定义的变量被称为“成员变量”</span><br><span class="hljs-comment">//成员变量没有赋值，系统赋默认值：一切向0看齐。</span><br><span class="hljs-type">int</span> no;<span class="hljs-comment">//学号</span><br>String name;<span class="hljs-comment">//姓名</span><br><span class="hljs-type">boolean</span> sex;<span class="hljs-comment">//性别</span><br><span class="hljs-type">int</span> age;<span class="hljs-comment">//年龄</span><br>String address;<span class="hljs-comment">//住址</span><br><span class="hljs-comment">//方法</span><br><span class="hljs-comment">//方法描述的是对象的动作信息</span><br><span class="hljs-comment">//当前例子就只描述属性，不描述方法。</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2、对象的创建和使用、内存分析"><a href="#2、对象的创建和使用、内存分析" class="headerlink" title="2、对象的创建和使用、内存分析"></a>2、对象的创建和使用、内存分析</h2><h3 id="1、对象的创建和使用"><a href="#1、对象的创建和使用" class="headerlink" title="1、对象的创建和使用"></a>1、对象的创建和使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OOTest01</span>&#123;<br>	publci <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br>		<span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><br>		<span class="hljs-type">int</span> StuNo=s.no;<br>		System.out.println(<span class="hljs-string">&quot;学号 =&quot;</span> + StuNo);<span class="hljs-comment">//0【默认值】</span><br>		System.out.println(<span class="hljs-string">&quot;学号 =&quot;</span> + s.no);<span class="hljs-comment">//0【默认值】</span><br>		s.no=<span class="hljs-number">10</span>;<br>		System.out.println(<span class="hljs-string">&quot;学号 =&quot;</span> + s.no);<span class="hljs-comment">//10</span><br><br>		<span class="hljs-comment">//再通过类实例化一个全新的对象</span><br>		<span class="hljs-comment">//stu是一个引用</span><br>		<span class="hljs-comment">//stu同时也是一个局部变量</span><br>		<span class="hljs-comment">//Student是变量的数据类型</span><br>		<span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>		System.out.println(<span class="hljs-string">&quot;学号 =&quot;</span> + stu.no);<span class="hljs-comment">// 0</span><br><br>		System.out.println(<span class="hljs-string">&quot;学号 =&quot;</span> + Student.no);<span class="hljs-comment">//编译错误，不能直接采用“类名”的方式访问</span><br>		<span class="hljs-comment">//因为no是实例变量，对象级别的变量，变量存储在java对象的内部，必须先有对象，通过对象才能访问no这个实例变量，不能直接通过“类名”访问</span><br>	&#125;<br>&#125;<br><span class="hljs-comment">//学生类</span><br><span class="hljs-comment">//学生类是一个模板</span><br><span class="hljs-comment">//描述了所有学生的共同特征【状态+行为】</span><br><span class="hljs-comment">//当前类只描述学生的状态信息【属性】</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-comment">//类体=属性+方法</span><br><br><span class="hljs-comment">//属性【存储数据采用变量的形式】</span><br><span class="hljs-comment">//由于变量定义在类体当中，方法体之外，这种变量称为成员变量</span><br><span class="hljs-comment">//所有学生都有学号信息</span><br><span class="hljs-comment">//但是每一一个学生的学号都是不同的</span><br><span class="hljs-comment">//所以要访问这个学号必须先创建对象，通过对象去访问学号信息</span><br><span class="hljs-comment">//学号信息不能直接通过&quot;类&quot;去访问，所以这种成员变量又被叫做:实例变量</span><br><span class="hljs-comment">//对象又被称为实例，实例变量又被称为对象变量。【对象级别的变量】</span><br><span class="hljs-comment">//不创建对象，这no变量的内存空间是不存在的，只有创建了对象，这个no变量内存空间才会创建。</span><br><span class="hljs-type">int</span> no;<br>String name;<span class="hljs-comment">//姓名</span><br><span class="hljs-type">boolean</span> sex;<span class="hljs-comment">//性别</span><br><span class="hljs-type">int</span> age;<span class="hljs-comment">//年龄</span><br>String address;<span class="hljs-comment">//住址</span><br></code></pre></td></tr></table></figure>

<ul>
<li>通过一个类可以实例化N个对象，</li>
<li>实例化对象的语法：<code>new 类名()</code></li>
<li>new是java语言当中的一个运算符</li>
<li>new运算符的作用是创建对象，在JVM堆内存当中开辟新的内存空间</li>
<li>方法区内存：在类加载的时候，class字节码代码片段被加载到该内存空间当中。</li>
<li>栈内存（局部变量）：方法代码片段执行的时候，会给该方法分配内存空间，在栈内存中压栈。</li>
<li>堆内存：new的对象在堆内存中存储</li>
</ul>
<p>对于<code>Student s = new Student ();</code></p>
<ul>
<li>student是一个引用数据类型</li>
<li>s是一个变量名</li>
<li>new Student()是一个学生对象</li>
<li>s是一个局部变量【在栈内存中存储】：<strong>引用</strong></li>
<li><strong>什么是对象？</strong> new运算符在堆内存中开辟的内存空间称为对象。</li>
<li><strong>什么是引用？</strong> 引用是一个变量，只不过这个变量中保存了另一个java对象的内存地址。</li>
<li>java语言当中，程序员不能直接操作堆内存，java中没有指针，不像C语言</li>
<li>java语言当中，程序员只能通过“引用”去访问堆内存当中对象内部的实例变量。</li>
</ul>
<h3 id="2、访问实例变量的语法格式："><a href="#2、访问实例变量的语法格式：" class="headerlink" title="2、访问实例变量的语法格式："></a>2、访问实例变量的语法格式：</h3><p>读取数据：引用.变量名<br>修改数据：引用.变量名 &#x3D; 值<br><code>int StuNo=s.no;</code></p>
<p>局部变量在栈<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>中存储<br>成员变量中的实例变量在堆内存的java对象内部存储</p>
<p>实例变量是一个对象一份，100个对象有100份</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span><br>&#123;<br>	<span class="hljs-type">int</span> id;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OOTest02</span><br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		Customer c= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>();<br>		System.out.println(c.id); <span class="hljs-comment">//0</span><br><br>		c=<span class="hljs-literal">null</span>;<br>		<span class="hljs-comment">//以下程序编译可以通过，因为符合语法</span><br>		<span class="hljs-comment">//运行出现空指针异常</span><br>		<span class="hljs-comment">//空引用访问“实例”相关的数据一定会出现空指针异常</span><br>		<span class="hljs-comment">//java.lang.NullPointerException</span><br>		System.out.println(c.id);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>“实例”相关的数据表示：这个访问的时候必须有对象的参与。这种数据就是实例相关的数据。</p>
<p><strong>重点：</strong> 实例变量必须先创建对象，通过引用的方式访问，不能直接使用<code>类名.</code>的方式访问</p>
<h3 id="3、内存分析"><a href="#3、内存分析" class="headerlink" title="3、内存分析"></a>3、内存分析</h3><p>1、JVM ( Java虚拟机)主要包括三块内存空间.分别是:栈内存、堆内存、方法区内存。</p>
<p>2、堆内存和方法区内存各有1个。一个线程一个栈内存。</p>
<p>3、方法调用的时候,该方法所需要的内存空间在栈内存中分配,称为压栈。方法执行结束之后,该方法所属的内存空间释放,称为弹栈。</p>
<p>4、栈中主要存储的是方法体当中的局部变量。</p>
<p>5、方法的代码片段以及整个类的代码片段都被存储到方法区内存当中,在类加载的时候这些代码片段会载入。</p>
<p>6、在程序执行过程中使用new运算符创建的java对象.存储在堆内存当中。对象内部有实例变量,所以实例变量存储在堆内存当中。</p>
<p>7、<strong>变量分类：</strong></p>
<ul>
<li>局部变量[方法体中声明]</li>
<li>成员变量[方法体外声明]<br>实例变量[前边修饰符没有static]<br>静态变量[前边修饰符中有static]</li>
</ul>
<p>8、<strong>静态变量存储在方法区内存当中。[先背会]</strong></p>
<p>9、三块内存当中<strong>变化最频繁</strong>的是<strong>栈内存</strong>,最先有数据的是方法区内存,垃圾回收器主要针对的是堆内存。</p>
<p>10、<strong>垃圾回收器</strong>[自动垃圾回收机制、GC机制]什么时候会考虑将某个java对象的内存回收呢?</p>
<ul>
<li><strong>当堆内存当中的java对象成为垃圾数据的时候.会被垃圾回收器回收。</strong></li>
</ul>
<p>11、<strong>什么时候堆内存中的java对象会变成垃圾呢?</strong></p>
<ul>
<li>没有更多的引用指向它的时候。这个对象无法被访问,因为访问对象只能通过引用的方式访问。</li>
</ul>
<h2 id="3、面向对象的封装性、static"><a href="#3、面向对象的封装性、static" class="headerlink" title="3、面向对象的封装性、static"></a>3、面向对象的封装性、static</h2><h3 id="1、封装的好处："><a href="#1、封装的好处：" class="headerlink" title="1、封装的好处："></a>1、封装的好处：</h3><ul>
<li>1、封装之后，对于那个事物来说，看不到这个事物比较复杂的一面，只能看到该事物简单的一面。复杂性封装，对外<strong>提供简单的操作入口</strong>。照相机就是一个很好的案例，照相机的实现原理比较复杂，但是对于使用照相机的人来说，操作起来是非常方便的。还有像电视机也是封装的，电视机内存实现非常复杂，但是对于使用者来说不需要关心内部的实现原理，只需要会操作遥控器即可。</li>
<li>2、封装之后会形成真正的“对象”，真正的“<strong>独立体</strong>”。</li>
<li>3、封装就意味着以后的程序可以重复使用。并且这个事物应该适应性比较强，在任何场合都可以使用。【<strong>可重用性</strong>】</li>
<li>4、封装之后，对于事物本身，提高了安全性【<strong>安全级别高</strong>】</li>
</ul>
<h3 id="2、封装的步骤："><a href="#2、封装的步骤：" class="headerlink" title="2、封装的步骤："></a>2、封装的步骤：</h3><p>1、所有属性私有化，使用private关键字进行修饰，private表示私有的，修饰的所有数据只能在本类中访问</p>
<p>2、对外提供简单的操作入口，也就是说外部程序要想访问age属性，必须通过这些简单的入口进行访问：</p>
<ul>
<li>对外提供两个公开的方法，分别是set方法和get方法</li>
<li>想修改age属性，调用set方法</li>
<li>想读取age属性，调用get方法</li>
</ul>
<p>3、set方法的命名规范：<code>public void set + 属性名首字母大写（形参）&#123; &#125;;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123; <br>	age = a; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>4、get方法的命名规范：<code>public 返回值类型 get + 属性名首字母大写（形参）&#123; &#125;;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span>&#123;<br>	<span class="hljs-keyword">return</span> age;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>5、需要背会的：</p>
<ul>
<li>setter和getter方法没有static关键字</li>
<li>有static关键字修饰方法怎么调用？<code>类名.方法名(实参);</code></li>
<li>没有static关键字修饰方法怎么调用？<code>引用.方法名(实参);</code></li>
</ul>
<p><strong>例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserTest</span><br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>		<span class="hljs-comment">//编译报错，age属性私有化，在外部程序中不能直接访问</span><br>		<span class="hljs-comment">//从此之后age属性非常的安全，但是有点太安全了。</span><br>		<span class="hljs-comment">//对于目前程序来说，age属性彻底在外部访问不到了。</span><br>		<span class="hljs-comment">//System.out.println(user.age);</span><br>       <br>       <span class="hljs-comment">//修改</span><br>       user.setAge(-<span class="hljs-number">100</span>);<span class="hljs-comment">//对不起，您提供的年龄不合法</span><br>       <span class="hljs-comment">//读取</span><br>       System.out.println(user.getAge());<span class="hljs-comment">//0</span><br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span><br>&#123;<br>	<span class="hljs-comment">//属性私有化</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>&#125;<br><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123; <br>	<span class="hljs-comment">//编写业务逻辑代码进行安全控制</span><br>	<span class="hljs-comment">//age = a; </span><br>	<br>	<span class="hljs-keyword">if</span>(a&lt;<span class="hljs-number">0</span>||a&gt;<span class="hljs-number">150</span>)&#123;<br>		System.out.println(<span class="hljs-string">&quot;对不起，您提供的年龄不合法&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-comment">//程序可以进行到这里的话，说明a是合法的，则进行赋值运算</span><br>	age = a; <br>&#125;<br><br><span class="hljs-keyword">public</span>  <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span>&#123;<br>	<span class="hljs-keyword">return</span> age;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4、java构造方法、构造器、对象与引用的概念、参数传递"><a href="#4、java构造方法、构造器、对象与引用的概念、参数传递" class="headerlink" title="4、java构造方法、构造器、对象与引用的概念、参数传递"></a>4、java构造方法、构造器、对象与引用的概念、参数传递</h2><h3 id="1、关于java类中中的构造方法："><a href="#1、关于java类中中的构造方法：" class="headerlink" title="1、关于java类中中的构造方法："></a>1、关于java类中中的构造方法：</h3><p>1、构造方法又被称为构造函数&#x2F;构造器&#x2F;Constructor</p>
<p>2、构造方法语法结构：<br><code>[修饰符列表] 构造方法名(形式参数列表)&#123; 构造方法体; &#125;</code></p>
<p>3、回顾普通方法的语法结构：<br><code>[修饰符列表] 返回值类型 方法名(形式参数列表)&#123; 方法体; &#125;</code></p>
<p>4、对于构造方法来说，“返回值类型”不需要指定，并且也不能写void。只要写上void，那么这个方法就成为普通方法了。</p>
<p>5、对于构造方法来说，构造方法的方法名必须与类名保持一致。</p>
<p>6、构造方法的作用？</p>
<ul>
<li>构造方法存在的意义是，通过构造方法的调用，可以创建对象。</li>
</ul>
<p>7、构造方法应该怎么调用？</p>
<ul>
<li>普通方法是这样调用的：方法修饰符中有static的时候：<code>类名.方法名（实参列表）</code>、方法修饰符列表中没有static的时候：<code>引用.方法名（实参列表）</code></li>
<li><code>new 构造方法名（实参列表）</code></li>
</ul>
<p>8、构造方法调用执行之后，有返回值吗？</p>
<ul>
<li>每一个构造方法实际上执行结束之后都有返回值，但是这个“return 值；”这样的语句不需要写。构造方法结束的时候java程序自动返回值。</li>
<li>并且返回值类型是构造方法所在类的类型。由于构造方法的返回值类型就是类本身，所以返回值类型不需要编写。</li>
</ul>
<p>9、注释和取消注释：Ctrl + &#x2F;、 多行注释：ctrl + shift +&#x2F;\</p>
<p>10、当一个类中没有定义任何构造方法的话，系统默认给该类提供一个无参数的构造方法，这个构造方法被称为缺省构造器。</p>
<p>11、当一个类显示的将构造方法定义出来了，那么系统则不再默认为这个类提供缺省构造器。建议开发中手动的为当前类提供无参数的构造方法。因为无参数的构造方法太常用了。</p>
<h3 id="2、构造方法的作用"><a href="#2、构造方法的作用" class="headerlink" title="2、构造方法的作用"></a>2、构造方法的作用</h3><ul>
<li>1、创建对象</li>
<li>2、创建对象的同时，初始化实例变量的内存空间。</li>
</ul>
<p>成员变量之实例变量，属于队象级别的变量，这种变量必须先有对象才能有实例变量。</p>
<p>实例变量没有手动赋值的时候，系统默认赋值，那么这个系统默认赋值是在什么时候完成的呢？是在类加载的时候么？</p>
<ul>
<li>不是的，因为类加载的时候只加载了代码片段，还没来得及创建对象。所以此时实例变量并没有初始化。</li>
<li>实际上，实例变量的内存空间是在构造方法执行过程当中完成开辟的，完成初始化的。</li>
<li>系统在默认赋值的时候，也是在构造方法执行过程当中完成的赋值。</li>
</ul>
<h3 id="3、对象与引用的概念"><a href="#3、对象与引用的概念" class="headerlink" title="3、对象与引用的概念"></a>3、对象与引用的概念</h3><ul>
<li><strong>对象</strong>：目前在使用new运算符在堆内存中开辟的内存空间称为对象。</li>
<li><strong>引用</strong>：是一个变量，不一定是局部变量，还可能是成员变量。引用保存了内存地址，指向了堆内存当中的对象。</li>
<li>所有访问实例相关的数据，都需要通过<code>“引用.”</code>的方式访问，因为只有通过引用才能找到对象。</li>
<li>只有一个空的引用，访问对象的实例相关的数据会出现空指针异常。</li>
</ul>
<h3 id="4、参数传递"><a href="#4、参数传递" class="headerlink" title="4、参数传递"></a>4、参数传递</h3><blockquote>
<p>主要研究和学习的是方法在调用的时候，涉及到参数传递的问题，到底是怎样传递数据的呢？</p>
<ul>
<li>值传递</li>
</ul>
</blockquote>
<blockquote>
<p>int i &#x3D; 10;<br>int j &#x3D; i ; i传递给j，实际上只是将i变量中保存的10传递给了j，j实际上是一个全新的内存空间</p>
</blockquote>
<blockquote>
<p>User u &#x3D; 0x1234;<br>User u2 &#x3D; u;<br>u传递给u2，实际上是将0x1234这个值赋给u2了，u和u2实际上是两个不同的局部变量，但是他们这两个变量指向堆内存中的同一个java对象。</p>
</blockquote>
<p>java语言当中方法调用的时候涉及到的参数传递的问题</p>
<p><strong>参数传递</strong>实际上传递的是变量中保存的具体值</p>
<p><strong>例一：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test01</span>()<br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<br>		<span class="hljs-comment">//int i = 10;</span><br>		<span class="hljs-comment">//add(i)等同于：add（10）</span><br>		<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>		add(i);<span class="hljs-comment">//add方法调用的时候，给add方法传递了一个变量i，实际上传递的是变量中保存的具体值</span><br>		System.out.println(<span class="hljs-string">&quot;main--&gt;&quot;</span>+ i );<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>		i++;<br>		System.out.println(<span class="hljs-string">&quot;add--&gt;&quot;</span>+ i);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译结果：<br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/69e16246977e476725c2b7d1dadec9a9-1741868481336-91.png" srcset="/img/loading.gif" lazyload alt="编译结果"><br><strong>例二：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test02</span>()&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">20</span>);<br>      <br>       <span class="hljs-comment">//User u =0x1234;</span><br>       <span class="hljs-comment">//add(u)等同于：add(0x1234)</span><br>        add(u);<span class="hljs-comment">//传递u给add方法的时候，实际上传递的是U变量中保存的值，只不过这个值是一个java对象的内存地址</span><br>        System.out.println(<span class="hljs-string">&quot;main--&gt;&quot;</span>+ u.age);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(User u )</span>&#123;<br>        u.age++;<br>        System.out.println(<span class="hljs-string">&quot;add--&gt;&quot;</span>+ u.age);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span><br>&#123;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        age = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译结果：<br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7eef229895d788415d1d99a26f22d5a5-1741868481336-93.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><strong>最终结论：</strong></p>
<p>方法调用的时候，涉及到参数问题，传递的时候，java只遵循一种语法机制，就是将变量中保存的“值”传递过去了，只不过有时候这个值是一个字面值10，有的时候是另一个java对象的内存地址0x1234。</p>
<h2 id="5、抽象类"><a href="#5、抽象类" class="headerlink" title="5、抽象类"></a>5、抽象类</h2><blockquote>
<p>抽象类为什么无法实例化，无法创建对象？<br>抽象类是：类和类之间有共同特征，将这些具有共同特征的类再进一步形成了抽象类。由于类本身是不存的，所以抽象类无法创建对象</p>
</blockquote>
<p><strong>1、什么是抽象类</strong></p>
<p>类和类之间有共同特征，将这些具有共同特征的类再进一步形成了抽象类。由于类本身是不存的，所以抽象类无法创建对象【无法实例化】</p>
<p><strong>2、抽象类属于什么类型？</strong></p>
<p>抽象类也属于引用数据类型</p>
<p><strong>3、抽象类怎么定义？</strong></p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">[修饰符列表] <span class="hljs-keyword">abstract</span> class 类名&#123;<br>	类体;<br>&#125;<br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure>

<p><strong>4、抽象类是无法实例化的，无法创建对象的，所以抽象类是用来被子类继承的。</strong></p>
<p><strong>5、final与abstract不能联合使用，这两个关键字是对立的</strong></p>
<p><strong>6、抽象类的子类可以是抽象类</strong></p>
<p><strong>7、抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法是供子类使用的。</strong></p>
<p><strong>8、抽象类关联到一个概念：抽象方法。</strong></p>
<p><strong>抽象方法</strong>表示没有实现的方法，没有方法体的方法。</p>
<p>例如：<code>public abstract void doSome();</code> 没有花括号</p>
<p>抽象方法特点是：</p>
<ul>
<li>特点1：没有方法体，以分号结尾。</li>
<li>特点2：前面修饰符列表中有abstract关键字</li>
</ul>
<p><strong>9、抽象类中不一定有抽象方法，抽象方法必须在抽象类中。</strong></p>
<p><strong>重要结论：【必须背会】</strong></p>
<p><strong>一个非抽象的类继承抽象类，必须将抽象类中的抽象方法实现了。<br>这是java语法上强行规定的，必须的，否则编译器报错。<br>抽象类则不需要。</strong></p>
<p>这里的覆盖或者重写，也可以叫做实现。（对抽象）</p>
<p><strong>面向抽象编程</strong></p>
<p>面向抽象编程，不要面向具体编程，降低程序的耦合度，提高程序的扩展力<br>这种编程思想符合OCP原则。</p>
<h2 id="6、接口"><a href="#6、接口" class="headerlink" title="6、接口"></a>6、接口</h2><h3 id="1、接口"><a href="#1、接口" class="headerlink" title="1、接口"></a>1、接口</h3><ul>
<li>接口也是一种引用数据类型。</li>
<li>接口是完全抽象的。（抽象类是半抽象。）或者也可以说接口是特殊的抽象类。</li>
</ul>
<p><strong>1、接口的语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">[修饰符列表] interface 接口名 &#123;<br>&#125;<br>[修饰符列表] class 类名&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>2、接口支持多继承，一个接口可以继承多个接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>,B&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>3、接口中只包含两部分内容</strong></p>
<ul>
<li><strong>常量</strong>（不能修改）</li>
<li><strong>抽象方法</strong></li>
</ul>
<p>接口没有其它内容，只有以上两部分。</p>
<p><strong>4、接口中的所有元素都是public修饰的</strong></p>
<p><strong>5、接口中的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95&spm=1001.2101.3001.7020">抽象方法</a>定义时：<code>public abstract</code> 修饰符可以省略</strong></p>
<p><strong>6、接口中的方法都是抽象方法，所以接口中的方法不能有结构体和方法体</strong></p>
<p><strong>7、接口中的常量的public 、static、final可以省略。</strong></p>
<p><strong>8、类实现接口实现方法</strong></p>
<p><strong>基础语法：</strong> 类和类之间叫做继承，类和接口之间叫做实现。</p>
<p><strong>语法结构：</strong></p>
<ul>
<li>继承使用<code>extends</code>关键字完成。</li>
<li>实现使用<code>implements</code>关键字完成。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyMath</span>&#123;<br>	<span class="hljs-type">double</span> PI=<span class="hljs-number">3.1415</span>;<br>	<span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>;<br>	<span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>;<br>&#125;<br><br><span class="hljs-comment">//正确写法</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMathImp1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyMath</span>&#123;<br>&#125;<br><br>错误：MyMathImp1不是抽象的，并且未覆盖MyMath中的抽象方法<br><span class="hljs-comment">/*class MyMathImp1 implements MyMath&#123;</span><br><span class="hljs-comment">&#125;*/</span><br><br>修正：<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMathImp1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyMath</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>		<span class="hljs-keyword">return</span> a + b;<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>		<span class="hljs-keyword">return</span> a - b;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>9、当一个非抽象的类实现接口的话，必须将接口中所有的抽象方法全部实现（重点）</strong></p>
<p><strong>10、面向接口的编程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//多态：父类型引用指向子类型的对象</span><br><span class="hljs-comment">//调用接口里面的方法(面向接口的编程)</span><br><span class="hljs-type">MyMath</span> <span class="hljs-variable">mm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyMathImp1</span>();<br>mm.sum(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure>

<p><strong>11、一个类可以实现多个接口</strong></p>
<p>这种机制弥补了java中的一个缺陷：java中的类和类只支持单继承。实际上单继承是为了简单而出现的，现实世界中存在多继承，java中的接口弥补了单继承带来的缺陷。</p>
<p><strong>12、继承和实现同时存在（extends和implements）</strong></p>
<p><code>extends</code> 关键字在前 ，<code>implements</code>关键字在后。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>()<br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">Flyable</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">cat</span>();<span class="hljs-comment">//多态</span><br>		f.fly();<span class="hljs-comment">//输出结果：***</span><br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span>&#123;<br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;***&quot;</span>)<br>	&#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>13、使用接口写代码时，可以使用多态（父类型引用指向子类型对象）</strong></p>
<h3 id="2、接口在开发中的作用（解耦合）"><a href="#2、接口在开发中的作用（解耦合）" class="headerlink" title="2、接口在开发中的作用（解耦合）"></a>2、接口在开发中的作用（解耦合）</h3><p>注意：接口在开发中的作用，类似于多态在开发中的作用。</p>
<p>多态：面向抽象编程，不要面向具体编程。降低程序的耦合度，提高程序的扩展力。</p>
<p><strong>接口是不是完全的？</strong></p>
<p>是的，而我们以后正好要求面向抽象编程。<br>面向抽象编程这句话以后可以修改为：面向接口编程。有了接口就有了可插拨。可插拔表示扩展力很强。不是焊接死的。</p>
<p><strong>面向接口编程，可以降低程序的耦合度，提高程序的扩展力。符合OCP开发原则。<br>接口的使用离不开多态机制。（接口+多态才可以达到降低耦合度）</strong></p>
<p>接口可以解耦合，解开的是调用者和实现者的耦合，<br>任何接口都有调用者和实现者。</p>
<ul>
<li><strong>调用者</strong>面向接口调用。</li>
<li><strong>实现者</strong>面向接口编写实现。</li>
</ul>
<h2 id="7、接口和抽象类的区别"><a href="#7、接口和抽象类的区别" class="headerlink" title="7、接口和抽象类的区别"></a>7、接口和抽象类的区别</h2><p><strong>仅语法上的区别</strong></p>
<ol>
<li><p><strong>抽象类是半抽象的<br>接口是完全抽象的</strong></p>
</li>
<li><p><strong>抽象类中有构造方法<br>接口中没有构造方法</strong></p>
</li>
<li><p><strong>接口和接口之间支持多继承<br>类和类之间只能单继承</strong></p>
</li>
<li><p><strong>一个类可以同时实现多个接口<br>一个抽象类只能继承一个类（单继承）</strong></p>
</li>
<li><p><strong>接口中只允许出现常量和抽象方法。</strong></p>
<p><strong>接口一般都是对“行为”的抽象</strong></p>
</li>
</ol>
<h2 id="8、Java中类和类之间的关系"><a href="#8、Java中类和类之间的关系" class="headerlink" title="8、Java中类和类之间的关系"></a>8、Java中类和类之间的关系</h2><h3 id="一、继承关系"><a href="#一、继承关系" class="headerlink" title="一、继承关系"></a>一、继承关系</h3><p><strong>继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。</strong> 在Java中继承关系通过关键字extends明确标识，在设计时一般没有争议性。在UML类图设计中，继承用一条带空心三角箭头的实线表示，从子类指向父类，或者子接口指向父接口。<br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/40f02aeeb414f08fd3d6ff5ed198cc5c-1741868481336-92.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="二、实现关系"><a href="#二、实现关系" class="headerlink" title="二、实现关系"></a>二、实现关系</h3><p><strong>实现指的是一个class类实现interface接口（可以是多个）的功能，实现是类与接口之间最常见的关系。</strong> 在Java中此类关系通过关键字implements明确标识，在设计时一般没有争议性。在UML类图设计中，实现用一条带空心三角箭头的虚线表示，从类指向实现的接口。<br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7c447decc581b9c06edd7efbd6e8d298-1741868481336-94.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h3 id="三、依赖关系"><a href="#三、依赖关系" class="headerlink" title="三、依赖关系"></a>三、依赖关系</h3><p><strong>简单的理解，依赖就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是类B的变化会影响到类A。</strong> 比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖。表现在代码层面，为类B作为参数被类A在某个method方法中使用。在UML类图设计中，依赖关系用由类A指向类B的带箭头虚线表示。<br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/efbb939297aa3480d733d04f00167fd1-1741868481336-95.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h3 id="四、关联关系"><a href="#四、关联关系" class="headerlink" title="四、关联关系"></a>四、关联关系</h3><p>关联体现的是两个类之间语义级别的一种强依赖关系，比如我和我的朋友，这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的。关联可以是单向、双向的。<strong>表现在代码层面，为被关联类B以类的属性形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量。</strong> 在UML类图设计中，关联关系用由关联类A指向被关联类B的带箭头实线表示，在关联的两端可以标注关联双方的角色和多重性标记。<br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/b1b4153537518dd9e1513ad2998ab0c1-1741868481336-96.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h3 id="五、聚合关系"><a href="#五、聚合关系" class="headerlink" title="五、聚合关系"></a>五、聚合关系</h3><p><strong>聚合是关联关系的一种特例，它体现的是整体与部分的关系，即has-a的关系。此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。</strong> 比如计算机与CPU、公司与员工的关系等，比如一个航母编队包括海空母舰、驱护舰艇、舰载飞机及核动力攻击潜艇等。表现在代码层面，和关联关系是一致的，只能从语义级别来区分。在UML类图设计中，聚合关系以空心菱形加实线箭头表示。<br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/32703ef854225b72df1e83a49d00c89c-1741868481336-97.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h3 id="六、组合关系"><a href="#六、组合关系" class="headerlink" title="六、组合关系"></a>六、组合关系</h3><p><strong>组合也是关联关系的一种特例，它体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合。它同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束</strong>， 比如人和人的大脑。表现在代码层面，和关联关系是一致的，只能从语义级别来区分。在UML类图设计中，组合关系以实心菱形加实线箭头表示。<br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/351e71e2d2e9194be9a6fbd0494840f2-1741868481336-98.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h2 id="9、is-a、is-like-a、has-a"><a href="#9、is-a、is-like-a、has-a" class="headerlink" title="9、is-a、is-like-a、has-a"></a>9、is-a、is-like-a、has-a</h2><h3 id="1、has-a"><a href="#1、has-a" class="headerlink" title="1、has a"></a>1、has a</h3><p><strong>关联关系：聚合</strong><br>凡是能够使用 has a 来描述的，统一以<strong>属性</strong>的方式存在</p>
<blockquote>
<p>例如 Customer has a FoodMenu（顾客有一个食物菜单）</p>
</blockquote>
<h3 id="2、is-a"><a href="#2、is-a" class="headerlink" title="2、is a"></a>2、is a</h3><p><strong>继承关系：继承</strong><br>凡是满足is a的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%A1%A8%E8%BE%BE%E5%BC%8F&spm=1001.2101.3001.7020">表达式</a>都可以设置为<strong>继承</strong></p>
<blockquote>
<p>例如 Cat is a Animal（猫是一种动物）</p>
</blockquote>
<h3 id="3、is-like-a"><a href="#3、is-like-a" class="headerlink" title="3、is like a"></a>3、is like a</h3><p><strong>实现关系：接口</strong><br>满足 is like a 的表达式也是一种<strong>继承</strong></p>
<p><strong>实现关系通常是：类实现接口</strong></p>
<p>但是在继承中，仅覆盖了父类方法即为Is-a；若在覆盖父类方法基础上有新增方法，则为Is-like-a。</p>
<p><strong>例子：</strong></p>
<p>1.假设你确定两件对象之间是is-a的关系，那么此时你应该使用继承。比方菱形、圆形和方形都是形状的一种。那么他们都应该从形状类继承。</p>
<p>2.假设你确定两件对象之间是has-a的关系，那么此时你应该使用聚合。比方电脑是由显示器、CPU、硬盘等组成的。那么你应该把显示器、CPU、硬盘这些类聚合成电脑类。</p>
<p>3.假设你确定两件对象之间是like-a的关系，那么此时你应该使用组合。比方空调继承于制冷机，但它同一时候有加热功能。那么你应该把让空调继承制冷机类，并实现加热接口</p>
<h2 id="10、访问控制权限、包和import"><a href="#10、访问控制权限、包和import" class="headerlink" title="10、访问控制权限、包和import"></a>10、访问控制权限、包和import</h2><h3 id="1、关于java语言当中的包机制"><a href="#1、关于java语言当中的包机制" class="headerlink" title="1、关于java语言当中的包机制:"></a>1、关于java语言当中的包机制:</h3><ul>
<li><strong>1、包又称为package</strong>, java中 引入package这种语法机制主要是为了方便程序的管理。<br>不同功能的类被分门别类放到不同的软件包当中，查找比较方便，管理比较方便，易维护。</li>
<li><strong>2、怎么定义package呢?</strong><br>在java源程序的第一行上编写package语句。<br>package只能编写一 个语句.<br><strong>语法结构:</strong><br><code>package 包名;</code></li>
<li>3、<strong>包名的命名规范:</strong><br>公司域名倒序+项目名+模块名+功能名;<br>采用这种方式重名的几率较低。因为公司域名具有全球唯一性。<br>例如:<br>com.bjpowernode . oa.user . service;<br>org . apache. tomcat.core ;</li>
<li><strong>4、包名要求全部小写，包名也是标识符，必须遵守标识符的命名规则</strong></li>
<li><strong>5、一个包对应的是一个目录</strong></li>
<li><strong>6、使用了package机制之后，应该怎样编译？怎么运行呢？</strong><br>使用package机制后，类名不在是Test ，而是<code>包名.类名</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bjpowernode;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span>()<br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<br>		<span class="hljs-comment">//创建Test对象</span><br>		<span class="hljs-comment">//以下代码编译错误：当省略包名之后，会在当前包下找Test</span><br>		<span class="hljs-comment">//实际上编译器去找：com.bjpowernode.Test了，这个类不存在。</span><br>		<span class="hljs-comment">//Test tt = new Test();</span><br>		<span class="hljs-comment">//System.out.println(tt);</span><br><br>		<span class="hljs-comment">//修改以上错误</span><br>		<span class="hljs-comment">//包名不要省略</span><br>		<span class="hljs-comment">//结论：什么时候前边的包名可以省略呢？ Test和Test1在同一个包下的时候不需要加包名。</span><br>		com.bjpowernode.javase.day.<span class="hljs-type">Test</span> <span class="hljs-variable">tt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">com</span>.bjpowernode.javase.day.Test();<br><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2、import"><a href="#2、import" class="headerlink" title="2、import"></a>2、import</h3><p>1、import 语句用来完成导入其他类，同一个包下的类不需要导入，不在同一个包下需要手动导入。</p>
<p>2、import语法格式：<br><code>import 类名；</code><br><code>import 包名.* ；</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bjpowernode;<br><span class="hljs-keyword">import</span> com.bjpowernode.javase.day.Test; <span class="hljs-comment">//导入包</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span>()<br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">Test</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>		System.out.println(x);<span class="hljs-comment">//com.bjpowernode.javase.day.Test</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>&#x2F;3、<strong>java.lang.*不需要手动引入，系统自动引入<br>lang：language语言包，是java语言的核心类，不需要手动引入。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;abc&quot;</span>;<br>System.out.println(s);<br><br><span class="hljs-comment">//Date d = new Date();//编译错误，因为没有Date类</span><br>需要 <span class="hljs-keyword">import</span> java.util.Date;<br></code></pre></td></tr></table></figure>

<p>4、什么时候需要import？</p>
<ul>
<li>不是java.lang包下，并且不在同一个包下的时候，需要使用import进行引入</li>
</ul>
<h3 id="3、访问控制权限"><a href="#3、访问控制权限" class="headerlink" title="3、访问控制权限"></a>3、访问控制权限</h3><h3 id="访问控制权限修饰符"><a href="#访问控制权限修饰符" class="headerlink" title="访问控制权限修饰符:"></a><strong>访问控制权限修饰符:</strong></h3><p>1、访问控制权限修饰符来控制元素的访问范围</p>
<p>2、访问控制权限修饰符包括:</p>
<ul>
<li><strong>public：</strong> 表示公开的，在任何位置都可以访问</li>
<li><strong>protected：</strong> 同包，子类</li>
<li><strong>缺省default（系统默认状态）：</strong> 同包</li>
<li><strong>private：</strong> 表示私有的，只能在本类中访问</li>
</ul>
<p>3、访问控制权限修饰符可以修饰类、变量、方法…</p>
<p>4、当<strong>某个数据只希望子类</strong>使用，使用protected进行修饰</p>
<p>5、修饰符的范围：<br><strong>private &lt; 缺省 &lt; protected &lt; public</strong></p>
<p>6、类只能采用public和缺省的修饰符进行修饰【内部类除外】</p>
<h1 id="六、关键字"><a href="#六、关键字" class="headerlink" title="六、关键字"></a>六、关键字</h1><h2 id="1、this关键字"><a href="#1、this关键字" class="headerlink" title="1、this关键字"></a>1、this关键字</h2><p>关于java语言当中的this关键字</p>
<blockquote>
<ul>
<li>1 this是一个关键字，翻译为：这个</li>
<li>2 this是一个引用，this是一个变量，this变量中保存了内存地址指向了自身，this存储在JVM堆内存java对象内部。</li>
<li>3 创建100个java对象，每一个对象都有this，也就是说有100个不同的this</li>
<li>4 this可以出现在“实例方法”中，this指向当前正在执行这个动作的对象。（this代表当前对象）</li>
<li>5 this在大多数情况下都是可以省略不写的</li>
<li>6 this不能使用带有static的方法中</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerTest</span><br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-comment">//创建Customer对象</span><br>		<span class="hljs-type">Customer</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>();<br>		c1.name = <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>		<br>		<span class="hljs-comment">//c1购物</span><br>		c1.shopping();<br><br>		<span class="hljs-type">Customer</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>();<br>		c2.name = <span class="hljs-string">&quot;lisi&quot;</span>;<br>		c2.shopping();<br><br>		<span class="hljs-comment">//调用doSome方法（修饰符列表上有static）</span><br>		<span class="hljs-comment">//采用&quot;类名.&quot;的方式访问，显然这个方法在执行的时候不需要对象的参加</span><br>		Customer.doSome();<br><br>		<span class="hljs-comment">//调用doOther方法 </span><br>		Customer.doOther();<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span><br>&#123;<br>	<span class="hljs-comment">//姓名</span><br>	String name;<br>	<br>	<span class="hljs-comment">//构造方法</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Customer</span><span class="hljs-params">()</span>&#123;<br>	<br>	&#125;<br>	<br>	<span class="hljs-comment">//不带有static关键字的方法</span><br>	<span class="hljs-comment">//顾客购物的行为</span><br>	<span class="hljs-comment">//每一个顾客购物最终的结果是不一样的</span><br>	<span class="hljs-comment">//所以购物这个行为是属于对象级别的行为</span><br>	<span class="hljs-comment">//由于每一个对象在执行购物这个行为的时候最终结果不同，所以购物这个动作必须有对象的参与</span><br>	<span class="hljs-comment">//重点：没有static关键字的方法被称为“实例方法”</span><br>	<span class="hljs-comment">//重点：没有static关键字的变量被称为“实例变量”</span><br>	<span class="hljs-comment">//注意：当一个行为/动作执行的过程中是需要对象参与的，那么这个方法一定要定义为“实例方法”，不要带static关键字</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shopping</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;在购物！&quot;</span>);<span class="hljs-comment">//完整写法</span><br>		System.out.println(name+<span class="hljs-string">&quot;在购物！&quot;</span>);<span class="hljs-comment">//this可以省略不写</span><br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSome</span><span class="hljs-params">()</span>&#123;<br>		<span class="hljs-comment">//这个执行过程中没有“当前对象”，因为带有static的方法是通过类名的方式访问的。</span><br>		<span class="hljs-comment">//或者说这个&quot;上下文&quot;当中没有&quot;当前对象&quot;,自然也不存在this(this代表的是当前正在执行的这个动作的对象)</span><br>		<br>		<span class="hljs-comment">//以下程序为什么编译错误呢？</span><br>		<span class="hljs-comment">//doSome方法调用不是对象去调用，是一个类名去调用，执行过程中没有“当前对象”。</span><br>		<span class="hljs-comment">//name是一个&quot;实例变量&quot;。以下代码的含义是:访问当前对象的name。</span><br>		<span class="hljs-comment">//System.out.println(name);</span><br>		<br>		<span class="hljs-comment">//static方法调用不需要对象，直接使用类名，所以执行过程中没有当前对象，所以不能使用this</span><br>		<span class="hljs-comment">//System.out.println(this);</span><br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doOther</span><span class="hljs-params">()</span>&#123;<br>		<span class="hljs-comment">//假设想访问name这个实例变量的话应该怎么做？</span><br>		<span class="hljs-comment">//System.out.println(name); //编译报错</span><br>		<br>		<span class="hljs-comment">//可以采用以下方案，但是以下方案，绝对不是访问当前对象的name</span><br>		<span class="hljs-comment">//创建对象</span><br>		<span class="hljs-type">Customer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>();<br>		System.out.println(c.name);<span class="hljs-comment">//这里访问的name是c引用指向对象的name</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>编译结果：</strong><br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/aa0a3eeaae0ce80af58c73d99f77989e-1741868481336-99.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><strong>实例方法必须有对象的存在</strong></p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">实例方法<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doOther</span><span class="hljs-params">()</span>&#123;<br>	System.out.println(<span class="hljs-string">&quot;do other!&quot;</span>);<br>&#125;<br><br>run是实例方法，调用run方法的一定是有对象存在的。一定先创造一个对象才能调用run方法<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>	System.out.println(<span class="hljs-string">&quot;run !&quot;</span>);<br>	<br>	doOther是一个实例方法，实例方法调用必须有对象的存在<br>	以下代码的含义就是：调用当前对象的doOther方法<br>	doOther();<span class="hljs-comment">//this大部分情况下可以省略</span><br>	<span class="hljs-built_in">this</span>.doOther();<span class="hljs-comment">//完整写法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>最终结论：</strong></p>
<ul>
<li>在带有static的方法当中不能直接访问实例变量和实例方法。</li>
<li>因为实例变量和实例方法都需要对象的存在。</li>
<li>而static的方法当中是没有this的，也就是说当前对象不存在。</li>
<li>自然也是无法访问当前对象的实例变量和实例方法。</li>
</ul>
<p><strong>this.什么时候不能省略？</strong></p>
<blockquote>
<p>用来区分局部变量和实例变量的时候，“this.”不能省略。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>()&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id; <span class="hljs-comment">//实例变量</span><br>	<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;<br>	<span class="hljs-built_in">this</span>.id = id; <span class="hljs-comment">// 等号前面的是实例变量，等号后面的是局部变量</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>this可以使用在哪里？</strong></p>
<ul>
<li>1 实例方法中，代表当前对象【语法格式：<code>this.</code>】</li>
<li>2 构造方法中,通过当前的构造方法调用其他的构造方法【语法格式：<code>this（实参）;</code>】</li>
</ul>
<p><strong>重点记忆：this()这种语法只能出现在构造函数第一行。</strong></p>
<p><strong>什么时候程序在运行的时候出现空指针异常呢？</strong></p>
<ul>
<li>空引用访问实例相关的数据，因为实例相关的数据就是对象相关的数据，这些数据在访问的时候必须有对象的参与，当空引用的时候，对象不存在，访问这些实例数据一定会出现空指针异常。</li>
</ul>
<p>实例相关的数据包括：</p>
<ul>
<li>实例变量【对象需要存在】</li>
<li>实例方法【对象需要存在】</li>
</ul>
<h2 id="2、static关键字"><a href="#2、static关键字" class="headerlink" title="2、static关键字"></a>2、static关键字</h2><ul>
<li>1 static：静态的</li>
<li>2 static修饰的方法是静态方法</li>
<li>3 static修饰的变量是静态变量</li>
<li>4 所有static修饰的元素都称为静态的，都可以使用<code>类名.</code>的方式访问，当然也可以采用<code>引用.</code>【但不建议】</li>
<li>5 static修饰的所有元素都是类级别的特征，和具体的对象无关</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Chinese</span>()&#123;<br>	<span class="hljs-comment">//所有中国人这个类的对象国籍都一样，这种特征属于类级别的特征，</span><br>	<span class="hljs-comment">//可以提升为整个模板的特征，可以在变量前添加static关键字修饰</span><br>	<span class="hljs-comment">//静态变量，静态变量在类加载的时候初始化，不需要创建对象，内存就开辟了。</span><br>	<span class="hljs-comment">//静态变量存储在方法区内存当中。</span><br>	<span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">country</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;中国&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChineseTest</span><br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">Chinese</span> <span class="hljs-variable">zhangsan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chinese</span>();<br>		System.out.println(Chinese.country);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>什么时候成员变量声明为实例变量呢 ？</strong></p>
<ul>
<li>所有对象都有这个属性，但是这个属性的值会随着这个对象的变化而变化【不同对象的这个属性具体的值不同】</li>
</ul>
<p><strong>什么时候成员变量声明为静态变量呢 ？</strong></p>
<ul>
<li>所有对象都有这个属性，并且所有对象这个属性的值是一样的，建议定义为静态变量，节省内存的开销。</li>
</ul>
<p><strong>静态变量在类加载的时候初始化，内存在方法区中开辟。访问的时候不需要创建对象，直接使用<code>类名.静态变量名</code>的方式访问。</strong></p>
<p>所有静态的数据都是可以采用<code>类名.</code>,也可以采用<code>引用.</code>，但是建议采用<code>类名.</code>的方式访问。<br>采用<code>引用.</code>的方式访问的时候，即使引用的是null，也不会出现空指针异常，因为访问静态的数据不需要对象的存在。</p>
<p><strong>可以使用static关键字来定义“静态代码块”：</strong></p>
<p>1、语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span>&#123;<br>	java语句;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2、静态代码块在类加载时执行，并且只执行一次。</p>
<p>3、静态代码块在一个类中可以编写多个，并且遵循自上而下的顺序依次执行。·</p>
<p>4、静态代码块的作用是什么？怎么用？用在哪？什么时候用？</p>
<blockquote>
<ul>
<li>这当然和具体的需求有关，例如项目中要求在类加载的时候执行代码完成日志的记录。那么这段记录日志的代码就可以编写到静态代码当中，完成日志记录</li>
<li>静态代码块是java为程序员准备的一个特殊的时刻，这个特殊的时刻被称为类加载时刻。若希望在此刻执行一段特殊的程序，这段程序可以直接放到静态代码当中。</li>
</ul>
</blockquote>
<p>5、通常在静态代码块当中完成预备工作，先完成数据的准备工作，例如：初始化连接池，解析XML配置文件…</p>
<p><strong>方法什么时候定义为静态的？</strong></p>
<blockquote>
<p>方法描述的是动作，当所有的对象执行这个动作的时候，最终产生影响是一样的。那么这个动作已经不再属于某一个对象动作了，可以将这个动作提升为类级别的动作，模板级别的动作。</p>
</blockquote>
<p>静态方法中无法直接访问实例变量和实例方法。</p>
<p>大多数方法都定义为实例方法，一般一个行为或者一个动作在发生的时候，都需要对象的参与。但是也有例外，例如：大多数“工具类”中的方法都是静态方法，因为工具就是方便编程，为了方便方法的调用，自然不需要new对象是最好的。</p>
<h2 id="3、final关键字"><a href="#3、final关键字" class="headerlink" title="3、final关键字"></a>3、final关键字</h2><p><strong>1、final是一个关键字，表示最终的，不可变的</strong></p>
<p>2、<strong>final修饰的类无法被继承</strong></p>
<p>3、<strong>final修饰的方法无法被覆盖</strong></p>
<p>4、<strong>final修饰的变量一旦被赋值之后，不可重新赋值</strong>【不可二次赋值】</p>
<p>5、<strong>final修饰的实例变量，必须手动赋值，不能采用系统默认值 final变量必须手动赋值，不能采用系统默认值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//final int age; //编译错误</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>或<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> num;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FinalTest</span><span class="hljs-params">()</span>&#123;<br>	<span class="hljs-built_in">this</span>.num = <span class="hljs-number">200</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>6、<strong>final修饰的引用，一旦指向某个对象之后，不能在指向其他对象，那么被指向的对象无法被垃圾回收器回收。</strong></p>
<p>final修饰的引用虽然指向某个对象之后不能指向其他对象，但是所指向的对象内部的内存是可以被修改的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">100</span>);<br><br>u = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">200</span>);<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">30</span>);<br><span class="hljs-comment">//user = new User (50); //final修饰的引用，一旦指向某个对象之后，不能在指向其他对象，那么被指向的对象无法被垃圾回收器回收。</span><br><br>System.out.println(user.id);  <span class="hljs-comment">//30</span><br>user.id = <span class="hljs-number">50</span>;<span class="hljs-comment">//final修饰的引用虽然指向某个对象之后不能指向其他对象，但是所指向的对象内部的内存是可以被修改的。</span><br><br>System.out.println(user.id);  <span class="hljs-comment">//50</span><br></code></pre></td></tr></table></figure>

<p>7、<strong>final修饰的实例变量，一般和static联合使用，被称为变量。</strong></p>
<p>final修饰的实例变量是不可变的，这种变量一般和static联合使用，被称为<strong>常量</strong>。</p>
<p>常量定义的语法格式【常量名全部大写，每个单词之间使用下划线连接】<br><code>public static final 类型 常量名 = 值</code></p>
<h2 id="4、super关键字"><a href="#4、super关键字" class="headerlink" title="4、super关键字"></a>4、super关键字</h2><p><strong>super的使用</strong></p>
<p><code>super.属性名</code>：【访问父类的属性】<br><code>super.方法名（实参）</code>：【访问父类的方法】<br><code>super(实参)</code>：【调用父类的构造方法】</p>
<p><strong>super应用</strong></p>
<p>1、super是一个关键字，全部小写<br>2、</p>
<ul>
<li>super能出现在实例方法中。</li>
<li>super的语法是：<code>super.</code> 或 <code>super()</code></li>
<li>super不能使用在静态方法中</li>
<li><code>super.</code>大部分情况下是可以省略的</li>
<li><code>super.</code>什么时候不可以省略？<br>父类和子类中有同名属性，或者说有同样的方法，想在子类中访问父类的，<code>super.</code>不可以省略。</li>
<li><code>super()</code>只能出现在构造方法的第一行，通过当前的构造方法去调用“父类”中的构造方法，目的是：创建子类对象的时候，先初始化父类型特征。</li>
</ul>
<p>3、super()：<br>表示通过子类的构造方法调用父类的构造方法。<br>模拟现实世界中的这种场景：要想有儿子，需要先有父亲</p>
<p>4、当一个构造方法第一行：<br>既没有this()又没有super()的话，默认会有一个super()；表示通过当前子类的构造方法调用父类的无参数构造方法。所以必须保证父类的无参数构造方法是存在的。</p>
<p>5、注意：this()和super()不能共存，他们都是只能出现在构造方法的第一行。</p>
<p>6、无论怎样，父类的构造方法是一定会执行的。</p>
<p><strong>super.什么时候不能省略？</strong></p>
<p>父中有，子中又有，如果想在子中访问“父的特征”，<code>super.</code>不能省略。</p>
<ul>
<li><code>this.name</code>：当前对象的name属性</li>
<li><code>super.name</code>：当前对象的父类型特征中的name属性</li>
</ul>
<h1 id="七、继承、多态"><a href="#七、继承、多态" class="headerlink" title="七、继承、多态"></a>七、继承、多态</h1><h2 id="1、继承、方法覆盖"><a href="#1、继承、方法覆盖" class="headerlink" title="1、继承、方法覆盖"></a>1、继承、方法覆盖</h2><h3 id="1、继承"><a href="#1、继承" class="headerlink" title="1、继承"></a>1、继承</h3><p>关于java语言当中的继承：</p>
<ul>
<li>1 继承是面向的对象三大特征之一，三大特征是封装、继承、多态。</li>
<li>2 继承“基本”的作用是：代码复用。但是继承最“重要”的作用是：有了继承才有了以后的“方法覆盖”和“多态机制”</li>
<li>3 继承语法格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[修饰符列表] class 类名 extends 父类名&#123;<br>	类体 = 属性 + 方法<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>4 java语言当中的继承只支持单继承，一个类不同同时继承很多类，只能继承一个类。【在C++中支持多继承】。</li>
<li>5 关于继承中的一些术语：<br>B类继承A类，其中：<br><strong>A类称为：父类、基类、超类、superclass<br>B类称为：子类、派生类、subclass</strong></li>
<li>6 在Java语言当中子类继承父类都继承那些数据？<br>私有的不支持继承<br>构造方法不支持继承<br>其他数据都可以被继承</li>
<li>7 虽然java语言当中只支持单继承，但是一个类也可以间接继承其他类，例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">C <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span>&#123;<br>&#125;<br>B <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;<br>&#125;<br>A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&#123;<br>&#125;<br>C类直接继承B类，但是C类间接继承T、A类。<br></code></pre></td></tr></table></figure>

<ul>
<li>8 java语言中假设一个类没有显示的继承任何类，该类默认继承JavaSE库中提供的java.lang.Object类。java语言中任何一个类中都有Object类的特征。</li>
</ul>
<h3 id="2、方法覆盖"><a href="#2、方法覆盖" class="headerlink" title="2、方法覆盖"></a>2、方法覆盖</h3><p><strong>1 方法覆盖又称方法重写（override[官方]、overwrite）</strong></p>
<p><strong>2 什么时候使用方法覆盖？</strong></p>
<p>当父类中的方法已经无法满足当前子类的业务需求，子类有必要将父类中继承过来的方法进行重新编写，这个编写过程称为方法重写&#x2F;方法覆盖。</p>
<p><strong>3 什么条件满足之后会发生重写呢？</strong></p>
<blockquote>
<p>代码满足什么条件之后，就构成方法的覆盖呢？</p>
</blockquote>
<ul>
<li>方法重写发生在具有继承关系的父子类之间</li>
<li>返回值类型相同，方法名相同，形参列表相同</li>
<li>访问权限不能更低，可以更高。</li>
<li>抛出异常不能更多，可以更少</li>
</ul>
<p>建议方法重写的时候尽量复制粘贴，容易导致没有产生覆盖。</p>
<p><strong>注意</strong></p>
<ul>
<li>私有方法不能继承，所以不能覆盖</li>
<li>构造方法不能继承，所以不能覆盖</li>
<li>静态方法不存在覆盖</li>
<li>覆盖只针对方法，不谈属性</li>
</ul>
<h2 id="2、多态"><a href="#2、多态" class="headerlink" title="2、多态"></a>2、多态</h2><h3 id="1、基础语法"><a href="#1、基础语法" class="headerlink" title="1、基础语法"></a>1、基础语法</h3><p><strong>向上转型（upcasting）</strong></p>
<blockquote>
<p>子类型–&gt;父类型<br>又被称为：自动类型转换</p>
</blockquote>
<p><strong>向下转型（downcasting）</strong></p>
<blockquote>
<p>父类型–&gt;子类型<br>又被称为：强制类型转换。【需要加强制类型转换符】</p>
</blockquote>
<p>无论是向上转型还是向下转型，两种类型之间必须要有继承关系。<br>没有继承关系，程序是无法编译通过的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">使用多态语法机制<br><span class="hljs-number">1.</span>Animal和Cat之间存在继承关系，Animal是父类，Cat是子类<br><span class="hljs-number">2.</span>Cat is a Animal<br><span class="hljs-number">3.</span><span class="hljs-keyword">new</span>  <span class="hljs-title class_">Cat</span>()创建的对象的类型是Cat，a2这个引用的数据类型是Animal，可见它们进行了类型转换<br>子类型转化为父类型，称为向上转型，或者称为自动类型转换。<br><span class="hljs-number">4.</span>Java中允许这种语法：父类型引用指向子类型对象。<br><br><span class="hljs-type">Aniaml</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br><span class="hljs-type">Aniaml</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><br>a1.move(); <span class="hljs-comment">//动物在移动</span><br>a2.move();<span class="hljs-comment">// 猫在走猫步</span><br><span class="hljs-comment">//a2.catchMouse();  //编译不通过，Animal类中没有catchMouse方法</span><br><span class="hljs-comment">//因为编译阶段编译器检查a2的类型是Animal类型，</span><br><span class="hljs-comment">//从Animal.class字节码文件当中查找catchMouse()方法，</span><br><span class="hljs-comment">//最终没有找到该方法,导致静态绑定失败，没有绑定成功，也就是说编译失败了。</span><br></code></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>java程序永远都分为编译阶段和运行阶段</li>
<li>先分析编译阶段，在分析运行阶段，编译无法通过，根本是无法运行的。</li>
<li>编译阶段编译器检查a2这个引用的数据类型为Animal，由于Animal.class字节码当中有move()方法，所以编译通过了。这个过程我们称为静态绑定，编译阶段绑定。只有静态绑定成功了才有后续的运行。</li>
<li>在程序运行阶段，JVM堆内存当中真实创建的对象是Cat对象，那么以下程序在运行阶段一定会调用Cat对象的move()方法，此时发生了程序的动态绑定，运行阶段绑定。</li>
<li>无论是Cat类有没有重写move的方法，运行阶段一定调用的是Cat对象的move方法，因为底层真实对象就是Cat对象</li>
<li>父类型引用指向子类型对象这种机制导致程序存在编译阶段绑定和运行阶段绑定两种不同的形态&#x2F;状态，这种机制可以称为一种多态语法机制。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">a3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 1.以下程序编译是没有问题的，因为编译器检查到a3的数据类型是Animal</span><br><span class="hljs-comment">* Animal和Cat之间存在继承关系，并且Anima1是父类型，Cat是子类型,</span><br><span class="hljs-comment">*父类型转换成子类型叫做向下转型，语法合格。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* 2、程序虽然编译通过了,但是程序在运行阶段会出现异常,因为JVM雄内存</span><br><span class="hljs-comment">*当中真实存在的对象是Bi rd类型, Bi rd对象无法转换成Cat对象，因为两种</span><br><span class="hljs-comment">*类型之间不存在任何继承关系，此时出现了著名的异常:java.lang . ClassCastException</span><br><span class="hljs-comment">类型转换异常，这种异常总是在“向下转型&quot;的时候会发生。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">Cat</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> (Cat)a3;<br></code></pre></td></tr></table></figure>

<p><strong>怎么解决 ClassCastException异常呢？</strong></p>
<blockquote>
<p>使用instanceof运算符可以避免出现以上异常。</p>
</blockquote>
<p><strong>instanceof运算符怎么使用？</strong></p>
<p><strong>语法格式：</strong><br><code>引用 instanceof 数据类型名</code></p>
<p><strong>以上运算符的执行结果类型是布尔类型，结果可能是true&#x2F;false</strong></p>
<p><strong>关于运算结果true&#x2F;false：</strong></p>
<p>假设：（a instanceof Animal）</p>
<ul>
<li>true 表示：a这个引用指向的对象是一个Animal类型</li>
<li>false表示：a这个引用指向的对象不是一个Animal类型。</li>
</ul>
<p><strong>Java规范中要求：在进行强制类型转换之前，建议采用instanceof运算符进行判断，避免ClassCastException异常的发生。</strong> 这是一种好习惯。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (a3 <span class="hljs-keyword">instanceof</span> Cat)&#123; <span class="hljs-comment">//a3是一个Cat类型的对象</span><br>	<span class="hljs-type">Cat</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> (Cat)a3;<br>	c3.catchMouse();<br>	&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a3 <span class="hljs-keyword">instanceof</span> Bird)&#123;<span class="hljs-comment">//a3是一个Bird类型的对象</span><br>		<span class="hljs-type">Bird</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> (Bird)a3;<br>		b2.fly();<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2、多态在实际开发中的作用"><a href="#2、多态在实际开发中的作用" class="headerlink" title="2、多态在实际开发中的作用"></a>2、多态在实际开发中的作用</h3><ul>
<li><ol>
<li>降低耦合度【解耦合】，提高程序的扩展力【软件开发的一个很重要的目标】</li>
</ol>
</li>
<li><ol>
<li>能使用多态尽量使用多态</li>
</ol>
</li>
<li><ol>
<li>父类型引用指向子类型对象</li>
</ol>
</li>
</ul>
<h1 id="八、数组"><a href="#八、数组" class="headerlink" title="八、数组"></a>八、数组</h1><h2 id="1、数组Array"><a href="#1、数组Array" class="headerlink" title="1、数组Array"></a>1、数组Array</h2><h3 id="1、数组相关基础知识"><a href="#1、数组相关基础知识" class="headerlink" title="1、数组相关基础知识"></a>1、数组相关基础知识</h3><ul>
<li>1、Java语言中的数组是一种<strong>引用数据类型</strong>。不属于基本数据类型。<strong>数组的父类是Object。</strong></li>
<li>2、数组实际上是一个容器，可以同时容纳多个元素。（<strong>数组是一个数据的集合</strong>）。<br>数组：字面意思是“一组数据”。</li>
<li>3、数组当中可以<strong>存储基本数据类型</strong>的数据，也可以<strong>存储“引用数据类型”</strong> 的数据。</li>
<li>4、数组因为是引用类型，所以<strong>数组对象</strong>是<strong>堆内存</strong>当中的。（<strong>数组是存储在堆当中的</strong>）。</li>
<li>5、数组当中如果<strong>存储的是“java对象”</strong> 的话，实际上<strong>存储的是java对象的“引用</strong>（内存地址）”，数组不能直接存储java对象。</li>
<li>6、数组的分类：一维数组、二维数组、三维数组、多维数组…(一维数组较多，二维数组偶尔使用)。</li>
<li>7、数组一旦创建，在java规定，长度不可变。（数组长度不可变）。</li>
<li>8、所有数组对象都有length属性（java自带的），用来获取数组中元素的个数。</li>
<li>9、java中的数组要求数组中的元素类型统一。</li>
<li>10、数组在内存方面存储的时候，数组中的元素内存地址（存储的每一个元素都是有规则的挨着排列的）是连续的。内存地址连续。这是数组存储元素的特点。数组实际上是一种简单的数据结构。</li>
<li>11、所有的数组都是拿“第一个小方框的内存地址”作为整个数组对象的内存地址。（数组中首元素的内存地址作为整个数组对象的内存地址）</li>
<li>12、数组中的每一个元素都是有下标的，下标从0开始，以1递增。最后一个元素的下标：length - 1<br>下标非常重要，因为我们对数组中的元素进行“存取”的时候都需要下标；来进行。</li>
</ul>
<h3 id="2、数组的优缺点"><a href="#2、数组的优缺点" class="headerlink" title="2、数组的优缺点"></a>2、数组的优缺点</h3><p><strong>优点：</strong></p>
<p>查询、检索某个下标上的元素时效率极高。可以说查询效率最高的一个数据结构。</p>
<blockquote>
<p>为什么检索效率高？</p>
<ul>
<li>第一：每一个元素的内存地址在空间存储上是连续的。</li>
<li>第二：每一个元素类型相同，所以占用空间大小一样。</li>
<li>第三：如果知道一个元素内存地址，知道每一个元素占用空间大小，又知道下标，所以通过一个数学表达式就可以计算出某个下标上的元素的内存地址。直接通过内存地址定位元素，所以数组的检索效率是最高的。</li>
</ul>
</blockquote>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>第一：由于为了保证数组中每个元素的内存地址连续，所以在数组上随即删除或者增加元素的时候效率较低，因为随机增删元素会涉及到后面元素统一向前或者向后位移的操作。</strong></li>
<li><strong>第二：数组不能存储大量数据，因为很难在空间上找到一块特别大的连续的内存</strong></li>
</ul>
<p><strong>注意：对于数组中最后一个元素的增删是没有效率影响的</strong></p>
<h2 id="2、一维数组"><a href="#2、一维数组" class="headerlink" title="2、一维数组"></a>2、一维数组</h2><h3 id="1、怎样声明一个一维数组"><a href="#1、怎样声明一个一维数组" class="headerlink" title="1、怎样声明一个一维数组"></a>1、怎样声明一个一维数组</h3><p><strong>语法格式：</strong><br><strong><code>int[] array;</code></strong><br><strong><code>double[] array;</code></strong><br><strong><code>boolean[] array;</code><br><code>String[] array;</code><br><code>Object[] array;</code></strong></p>
<h3 id="2、怎样初始化一个一维数组呢？"><a href="#2、怎样初始化一个一维数组呢？" class="headerlink" title="2、怎样初始化一个一维数组呢？"></a>2、怎样初始化一个一维数组呢？</h3><p>包括两种方式：<strong>静态初始化一维数组、动态初始化一维数组</strong></p>
<p><strong>静态初始化一维数组</strong>：<code>int[] array = &#123;100,200,300&#125;;</code>、<code>String[] str = &#123;&quot;as&quot;,&quot;cs&quot; ,&quot;ds&quot;&#125;;</code><br>也可以使用 <code>int array[] = &#123;1,2,3&#125;</code>，这是C++风格，不建议在java中使用</p>
<p><strong>动态初始化一维数组</strong>：<br><code>int[] array = new int [5];</code> 这里的5表示数组元素个数,初始化一个5个长度的int类型数组，每个元素默认值为0</p>
<p><code>String[] names = new String[6];</code> 初始化6个长度的String类型数组，每个元素默认值null</p>
<h3 id="3、对一维数组中的元素访问"><a href="#3、对一维数组中的元素访问" class="headerlink" title="3、对一维数组中的元素访问"></a>3、对一维数组中的元素访问</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayTest01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>       <br>       <span class="hljs-comment">//取（读）</span><br>        System.out.println(a.length);<br>        System.out.println(<span class="hljs-string">&quot;第一个元素是&quot;</span> + a[<span class="hljs-number">0</span>]);<br>        System.out.println(<span class="hljs-string">&quot;最后一个元素是&quot;</span> + a[<span class="hljs-number">4</span>]);<br>        System.out.println(<span class="hljs-string">&quot;最后一个元素是&quot;</span> + a[a.length - <span class="hljs-number">1</span>]);<br><br>		<span class="hljs-comment">//存（改）</span><br>        a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//把第一个元素修改</span><br>        <br>        a[a.length-<span class="hljs-number">1</span>] = <span class="hljs-number">999</span>;<span class="hljs-comment">//把最后一个元素修改</span><br>        <br>        System.out.println(<span class="hljs-string">&quot;第一个元素是&quot;</span> + a[<span class="hljs-number">0</span>]);<br>        System.out.println(<span class="hljs-string">&quot;最后一个元素是&quot;</span> + a[<span class="hljs-number">4</span>]);<br>        System.out.println(<span class="hljs-string">&quot;最后一个元素是&quot;</span> + a[a.length - <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>输出结果：</strong><br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/79be76fba5d72b5e36bccf7138ed626f-1741868481336-100.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>4、 一维数组的遍历</p>
<p><strong>遍历写法：</strong></p>
<p>提示：下标越界会出现异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">     接上面代码<br>     <br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; a.length; i++)&#123;<br>          System.out.println(a[i]);<br>      &#125;<br>      <br><span class="hljs-comment">//颠倒遍历</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a.length - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>          System.out.println(<span class="hljs-string">&quot;颠倒顺序输出--&gt;&quot;</span> + a[i]);<br>      &#125;<br></code></pre></td></tr></table></figure>

<p><strong>结果：</strong><br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/fd4a5b163d5e1d05098dac6a4d077c86-1741868481336-101.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h3 id="5、静态存储Object类"><a href="#5、静态存储Object类" class="headerlink" title="5、静态存储Object类"></a>5、静态存储Object类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">o2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">o3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>Object[] object= &#123;o1,o2,o3&#125;;<br><br><span class="hljs-comment">/*或</span><br><span class="hljs-comment">Object[] object= &#123;new Object(),new Object(),new Object()&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; object.length; i++)&#123;<br>	System.out.println(object[i]);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6、动态初始化一维数组"><a href="#6、动态初始化一维数组" class="headerlink" title="6、动态初始化一维数组"></a>6、动态初始化一维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-comment">//声明定义一个数组，采用动态初始化的方式创建</span><br>        <span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<span class="hljs-comment">//创建长度为4的int数组，数组中每个元素的默认值为0</span><br>		<br>		<span class="hljs-comment">//遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;数组中的下标为&quot;</span> + i +<span class="hljs-string">&quot;的元素是&quot;</span> + a[i]);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>输出结果：</strong><br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/f32ff2631bcb9c10b0b18f8534fd4a4f-1741868481336-102.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h3 id="7、什么时候采用静态初始化方法-动态初始化方法？"><a href="#7、什么时候采用静态初始化方法-动态初始化方法？" class="headerlink" title="7、什么时候采用静态初始化方法&#x2F;动态初始化方法？"></a>7、什么时候采用静态初始化方法&#x2F;动态初始化方法？</h3><blockquote>
<p>当你创建数组的时候，确定数组中存储哪些具体的元素的时候，采用静态初始化。<br>当你创建数组的时候，不确定数组中存储哪些数据，你可以采用动态初始化的方式，预先分配内存空间。</p>
</blockquote>
<h3 id="8、方法的参数为数组"><a href="#8、方法的参数为数组" class="headerlink" title="8、方法的参数为数组"></a>8、方法的参数为数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-comment">//调用方法时传一个数组</span><br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>        printArray(a);<br>        <br>        <span class="hljs-comment">//不能printArray(&#123;1,2,3&#125;);没有这个语法</span><br>       <span class="hljs-comment">/* 或</span><br><span class="hljs-comment">        printArray(new int[] &#123;1,2,3&#125;);</span><br><span class="hljs-comment">        */</span><br>    &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>                System.out.println( array[i]);<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="9、数组中存储引用数据类型"><a href="#9、数组中存储引用数据类型" class="headerlink" title="9、数组中存储引用数据类型"></a>9、数组中存储引用数据类型</h3><p><strong>对于数组来说，实际上只能存储java对象的“内存地址”。数组中存储的每个元素都是“引用”</strong></p>
<p>提示：不能存放别的引用数据类型</p>
<p><strong>如果继承该引用数据类型的数据类型可以使用该数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>        Animal[] animals = &#123;a1,a2&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; animals.length; i++)&#123;<br>            animals[i].move();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal move&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>运行结果：</strong><br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/109c50cfe0f51535aed647c4bdc8216e-1741868481336-103.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h3 id="10、输出数组的方法"><a href="#10、输出数组的方法" class="headerlink" title="10、输出数组的方法"></a>10、输出数组的方法</h3><p><strong>错误示范</strong>：<code>System.out.println(array);　　//这样输出的是数组的首地址，而不能打印出数组数据</code></p>
<p><strong>正确写法：</strong><br><code>int[] array= &#123;1,2,3,4,5,6&#125;;</code></p>
<p><strong>方式一：for循环</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;array.length;i++)<br>&#123;<br>System.out.println(array[i]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出为：（自动换行格式的）</p>
<p><strong>方式二：for each</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a:array)<br>System.out.println(a);<br></code></pre></td></tr></table></figure>

<p>输出格式同方式一。</p>
<p><strong>方式三：Arrays类中的toString方法（注意，是Arrays不是Array，Arrays类位于java.util包下）</strong><br>需要导入<code>import java.util.Arrays</code>包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array= &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>System.out.println(Arrays.toString(array));<br></code></pre></td></tr></table></figure>

<h3 id="11、数组扩容"><a href="#11、数组扩容" class="headerlink" title="11、数组扩容"></a>11、数组扩容</h3><p><strong>java中对数组的扩容是：</strong></p>
<blockquote>
<p>先新建一个大容量的数组，然后将小容量数组中的数据一个一个拷贝到大数据当中。</p>
</blockquote>
<p>结论：数组扩容效率较低。因为涉及到拷贝的问题。所以在以后的开发中请注意：尽可能少的进行数组的拷贝。可以在创建数组对象的时候预估计以下多长合适，最好预估准确，这样可以减少数组的扩容次数，提高效率。</p>
<p><strong>第一种方法，建立一个新的数组，通过for循环来进行拷贝扩容</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[a.length*<span class="hljs-number">2</span>];<span class="hljs-comment">//a.length 长度；a数组的长度。即数组中数据的个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++)&#123;<br>b[i]=a[i];<br>&#125;<br>System.out.println(Arrays.toString(b));<span class="hljs-comment">//这个函数就是将数组b进行遍历输出</span><br><span class="hljs-comment">//如果不明白遍历什么意思，建议先学习遍历后再来看此篇文章</span><br></code></pre></td></tr></table></figure>

<p><strong>第二种方法：固定的写法。System.Arrays.copy(a,0,b,0,a.length);</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">20</span>];<br>System.arraycopy(a,<span class="hljs-number">0</span>,c,<span class="hljs-number">0</span>,a.length);<br><span class="hljs-comment">//a，需要复制的内容。第一个0（零）：在a中开始复制的内容的位置</span><br><span class="hljs-comment">//c,要复制的载体，在这里写c就是将a中需要复制的内容赋值给c</span><br><span class="hljs-comment">//第二个0（零）：在c中开始复制的位置</span><br><span class="hljs-comment">//a.length:要复制的元素量</span><br>System.out.println(Arrays.toString©);<br></code></pre></td></tr></table></figure>

<p><strong>方法三：利用函数方法直接扩容</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//原理，利用Arrays中的函数进行扩容</span><br><br><span class="hljs-type">int</span>[] d=Arrays.copyOf(a,<span class="hljs-number">22</span>);<span class="hljs-comment">//此函数的作用就是复制a的值。定义d的长度</span><br><br><span class="hljs-comment">// Arrays.copyOf(a,22); a，需要复制的内容（a数组），22：定义d数组的长度</span><br>System.out.println(Arryas.toString(d));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="12、数组拷贝"><a href="#12、数组拷贝" class="headerlink" title="12、数组拷贝"></a>12、数组拷贝</h3><p><strong>数组拷贝的方法</strong>：<code>System.arraycopy( Object src,int srcPos,Object dest, int destPos,int length)</code></p>
<blockquote>
<p>Object src：源数组<br>int srcPos：源数组起点下标<br>Object dest：目标数组<br>int destPos：目标数组起点下标<br>int length：拷贝的源数组的长度</p>
</blockquote>
<p><strong>数组中存储的元素是引用也可以拷贝。且拷贝的是对象的内存地址</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayTest3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] src = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>&#125;;<span class="hljs-comment">//拷贝源</span><br><br>        <span class="hljs-type">int</span>[] dest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">20</span>];<span class="hljs-comment">//拷贝目标</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; dest.length; i++)&#123;<br>            System.out.print(dest[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <br>        System.out.println();<br>        <br>        System.arraycopy(src,<span class="hljs-number">1</span>,dest,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//进行拷贝</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; dest.length; i++)&#123;<br>            System.out.print(dest[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>运行结果：</strong><br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5f0163d5d127811b4b831e608ca29911-1741868481336-104.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h2 id="3、-排序"><a href="#3、-排序" class="headerlink" title="3、 排序"></a>3、 排序</h2><h3 id="1、冒泡排序算法"><a href="#1、冒泡排序算法" class="headerlink" title="1、冒泡排序算法"></a>1、冒泡排序算法</h3><p><strong>思想：</strong></p>
<p>1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>2、对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>3、针对所有的元素重复以上的步骤，除了最后一个。<br>4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<p><strong>举例：</strong><br><strong>(1)要排序数组:[10,1,35,61,89,36,55]</strong></p>
<p>(2)第一趟排序：</p>
<p>第一次排序：10和1比较，10大于1，交换位置 　　 　 [1,10,35,61,89,36,55]</p>
<p>第二趟排序：10和35比较，10小于35，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>第三趟排序：35和61比较，35小于61，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>第四趟排序：61和89比较，61小于89，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>第五趟排序：89和36比较，89大于36，交换位置　　　[1,10,35,61,36,89,55]</p>
<p>第六趟排序：89和55比较，89大于55，交换位置　　　[1,10,35,61,36,55,89]</p>
<p>第一趟总共进行了六次比较，排序结果：[1,10,35,61,36,55,89]</p>
<p>(3)第二趟排序：</p>
<p>第一次排序：1和10比较，1小于10，不交换位置　　[1,10,35,61,36,55,89]</p>
<p>第二次排序：10和35比较，10小于35，不交换位置 [1,10,35,61,36,55,89]</p>
<p>第三次排序：35和61比较，35小于61，不交换位置 [1,10,35,61,36,55,89]</p>
<p>第四次排序：61和36比较，61大于36，交换位置　　　[1,10,35,36,61,55,89]</p>
<p>第五次排序：61和55比较，61大于55，交换位置　　　[1,10,35,36,55,61,89]</p>
<p>第二趟总共进行了5次比较，排序结果：[1,10,35,36,55,61,89]</p>
<p>(4)第三趟排序：</p>
<p>1和10比较，1小于10，不交换位置　　[1,10,35,36,55,61,89]</p>
<p>第二次排序：10和35比较，10小于35，不交换位置 [ 1,10,35,36,55,61,89]</p>
<p>第三次排序：35和36比较，35小于36，不交换位置 [1,10,35,36,55,61,89]</p>
<p>第四次排序：36和61比较，36小于61，不交换位置　　　[1,10,35,36,55,61,89]</p>
<p>第三趟总共进行了4次比较，排序结果：[1,10,35,36,55,61,89]</p>
<p>到目前位置已经为有序的情形了。<br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2a3ccedd0c3d3cbc84526ac38c148956-1741868481336-105.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><strong>平均时间复杂度：O(n²)</strong></p>
<blockquote>
<p>最好情况：O(n)<br>最坏情况：O(n²)</p>
</blockquote>
<p><strong>空间复杂度：O(1)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> temp ; <span class="hljs-comment">//临时变量，存储数据</span><br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a.length-<span class="hljs-number">1</span> ; i &gt; <span class="hljs-number">0</span> ; i-- )&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; j &lt; a.length-<span class="hljs-number">1</span> ; j++)&#123;<br>                <span class="hljs-keyword">if</span> (a[j] &gt; a[j+<span class="hljs-number">1</span>])&#123;<br>                    temp = a[j];<br>                    a[j] = a[j+<span class="hljs-number">1</span>];<br>                    a[j+<span class="hljs-number">1</span>] = temp;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length ; i++)&#123;<br>            System.out.print(a[i]+ <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h3><p><strong>思想：</strong><br>简单选择排序采用最简单的选择方式，从头至尾顺序扫描序列找出最小的一个关键字，和第一个关键字交换，接着从剩下的关键字中继续这种选择和交换，最终使序列有序。</p>
<p><strong>图解：</strong><br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7b43a6b5bb5e85bd73b6fa29bb70eb0a-1741868481336-106.png" srcset="/img/loading.gif" lazyload alt="图片来源于百度"><br><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; a.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (a[min] &gt; a[j]) &#123;<br>                    min = j;<br>                &#125;<br>            &#125;<br>                <span class="hljs-type">int</span> temp;<br>                temp = a[i];<br>                a[i] = a[min];<br>                a[min] = temp;<br>        &#125;<br><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; a.length ; i++)&#123;<br>            System.out.println(a[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4、查找"><a href="#4、查找" class="headerlink" title="4、查找"></a>4、查找</h2><h3 id="1、二分查找法"><a href="#1、二分查找法" class="headerlink" title="1、二分查找法"></a>1、二分查找法</h3><p><strong>思想：</strong></p>
<p>假设数据是按升序排序的，对于给定值x，从序列的中间位置开始比较，如果当前位置值等于x，则查找成功；若x小于当前位置值，则在数列的前半段中查找；若x大于当前位置值则在数列的后半段中继续查找，直到找到为止。</p>
<p><strong>示例：</strong><br>假如有一组数为3，12，24，36，55，68，75，88要查给定的值24.可设三个变量front，mid，end分别指向数据的上界，中间和下界，mid&#x3D;（front+end）&#x2F;2.</p>
<p>1、开始令front&#x3D;0（指向3），end&#x3D;7（指向88），则mid&#x3D;3（指向36）。因为mid&gt;x，故应在前半段中查找。</p>
<p>2、令新的end&#x3D;mid-1&#x3D;2，而front&#x3D;0不变，则新的mid&#x3D;1。此时x&gt;mid，故确定应在后半段中查找。</p>
<p>3、令新的front&#x3D;mid+1&#x3D;2，而end&#x3D;2不变，则新的mid&#x3D;2，此时a[mid]&#x3D;x，查找成功。</p>
<p>如果要查找的数不是数列中的数，例如x&#x3D;25，当第三次判断时，x&gt;a[mid]，按以上规律，令front&#x3D;mid+1，即front&#x3D;3，出现front&gt;end的情况，表示查找不成功。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(Integer[] srcArray, <span class="hljs-type">int</span> des)</span> &#123;<br>    <span class="hljs-comment">//定义初始最小、最大索引</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> srcArray.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//确保不会出现重复查找，越界</span><br>    <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>        <span class="hljs-comment">//计算出中间索引值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (end + start)/<span class="hljs-number">2</span> ;<br>        <span class="hljs-keyword">if</span> (des == srcArray[mid]) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-comment">//判断下限</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (des &lt; srcArray[mid]) &#123;<br>            end = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//判断上限</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            start = mid  + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//若没有，则返回-1</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5、一维数组的应用"><a href="#5、一维数组的应用" class="headerlink" title="5、一维数组的应用"></a>5、一维数组的应用</h2><p><strong>一维数组模拟栈数据结构</strong></p>
<p><strong>要求：</strong></p>
<ul>
<li>1、这个栈可以存储java中任何引用数据类型。</li>
<li>2、在栈中提供push方法模拟压栈。（栈满会有提示信息）</li>
<li>3、在栈中提供pop方法模拟弹栈。（栈空了也要有提示信息）</li>
<li>4、编写测试程序，new栈对象，调用push、pop方法来模拟压栈弹栈动作。</li>
</ul>
<p><strong>MyStack类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><br>    <span class="hljs-comment">/**属性私有化需要get和set方法*/</span><br>    <span class="hljs-keyword">private</span> Object[] elements;<br><br>    <span class="hljs-comment">/**栈帧，永远指向栈顶元素。</span><br><span class="hljs-comment">    栈顶初始默认值应该是-1，因为刚开始栈是空的没有元素。*/</span><br>    <span class="hljs-keyword">private</span>  <span class="hljs-type">int</span> index ;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//一维数组动态初始化</span><br>        <span class="hljs-comment">//默认初始化容量为10</span><br>        <span class="hljs-built_in">this</span>.elements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-comment">//给index初始化</span><br>        <span class="hljs-built_in">this</span>.index = -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 压栈的方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj 被压入元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">push</span><span class="hljs-params">(Object obj)</span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.index &gt;= <span class="hljs-built_in">this</span>.elements.length - <span class="hljs-number">1</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;栈已满，压栈失败！&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//程序能走到这里，说明栈没满</span><br>        <span class="hljs-comment">//向栈中加1个元素，栈帧向上移动一个位置。</span><br>        <span class="hljs-built_in">this</span>.index++;<br>        <span class="hljs-built_in">this</span>.elements[index] = obj;<br>        <span class="hljs-comment">//所有System.out.println()方法执行时。如果输出引用的话，自动调用引用的toString()方法</span><br>        System.out.println(<span class="hljs-string">&quot;压栈&quot;</span> + obj + <span class="hljs-string">&quot;元素成功，栈帧指向&quot;</span> + index);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 弹栈的方法，从数组中取出一个元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> )&#123;<br>           System.out.println(<span class="hljs-string">&quot;弹栈失败，栈已空&quot;</span>);<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>        System.out.print(<span class="hljs-string">&quot;弹栈&quot;</span> + elements[index] + <span class="hljs-string">&quot;元素成功,&quot;</span>);<br>        index--;<br>        System.out.println(<span class="hljs-string">&quot;栈帧指向&quot;</span> + index);<br>    &#125;<br><br>    <span class="hljs-comment">/**set 和 get也许用不上，但是必须写上，这是规则</span><br><span class="hljs-comment">    封装：第一步：属性私有化，第二步：对外提供set和get方法。*/</span><br>    <span class="hljs-keyword">public</span> Object[] getElements() &#123;<br>        <span class="hljs-keyword">return</span> elements;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setElements</span><span class="hljs-params">(Object[] elements)</span> &#123;<br>        <span class="hljs-built_in">this</span>.elements = elements;<br>    &#125;<br>&#125;<br><br><span class="hljs-number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960</span><br></code></pre></td></tr></table></figure>

<p><strong>StackTest类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SatckTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//创建一个栈对象，初始化容量是10个</span><br>        <span class="hljs-type">MyStack</span> <span class="hljs-variable">stack</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyStack</span>();<br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br><br>        <span class="hljs-comment">//压这个元素失败了</span><br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br><br>        stack.pop();<br>        stack.pop();<br>        stack.pop();<br>        stack.pop();<br>        stack.pop();<br>        stack.pop();<br>        stack.pop();<br>        stack.pop();<br>        stack.pop();<br>        stack.pop();<br>        stack.pop();<br>    &#125;<br>&#125;<br><span class="hljs-number">1234567891011121314151617181920212223242526272829303132</span><br></code></pre></td></tr></table></figure>

<p><strong>输出结果：</strong><br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/8d313ccd8561886f1399ba22e3140d74-1741868481336-107.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h2 id="6、二维数组的应用"><a href="#6、二维数组的应用" class="headerlink" title="6、二维数组的应用"></a>6、二维数组的应用</h2><p><strong>为某个酒店编写程序：酒店管理系统，模拟订房、退房、打印所有房间状态等功能</strong></p>
<p><strong>要求：</strong></p>
<ul>
<li>1、该系统的用户是：酒店前台。</li>
<li>2、酒店中所有房间使用一个二维数组来模拟：<code>Room[][] rooms;</code></li>
<li>3、酒店中的每一个房间应该是一个java对象：Room。</li>
<li>4、每一个房间Room应该有：房间编号、房间类型属性、房间是否空闲</li>
<li>5、系统应该对外提供哪些功能：<br>可以预定房间：用户输入房间编号，订房。<br>可以退房：用户输入房间编号，退房。<br>可以查看所有房间的状态：用户输入某个指令应该可以查看所有房间状态。</li>
</ul>
<p><strong>HotelSystem：</strong> 酒店前台系统</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HotelSystem</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建酒店对象</span><br>       <span class="hljs-type">Hotel</span> <span class="hljs-variable">hotel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hotel</span>();<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        首先输出一个欢迎界面</span><br><span class="hljs-comment">        */</span><br>        System.out.println(<span class="hljs-string">&quot;************************&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;   欢迎使用本酒店管理系统  &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;   请输入对于的功能编号：  &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;   1    查看房间列表     &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;   2    订房            &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;   3    退房            &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;   0    退出系统         &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;************************&quot;</span>);<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//循环一直可以使用</span><br>        <span class="hljs-keyword">while</span> (flag)&#123;<br>            System.out.print(<span class="hljs-string">&quot;请输入功能编号：&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.nextInt();<br>            <span class="hljs-keyword">switch</span> (i)&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                    System.out.println(<span class="hljs-string">&quot;已退出系统，欢迎下次光临！&quot;</span>);<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    hotel.print();<br>                    <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                    System.out.print(<span class="hljs-string">&quot;请输入订房编号&quot;</span>);<br>                    <span class="hljs-type">Scanner</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> s1.nextInt();<br>                    hotel.order(i1);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                    System.out.print(<span class="hljs-string">&quot;请输入退房编号&quot;</span>);<br>                    <span class="hljs-type">Scanner</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> s2.nextInt();<br>                    hotel.exit(i2);<br>                    <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-keyword">default</span>:<br>                    System.out.println(<span class="hljs-string">&quot;输入功能编号有误，请重新输入&quot;</span>);<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Hotel类：</strong> 酒店对象，包含二维数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">酒店对象，酒店中有二维数组，二维数组模拟酒店房间</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hotel</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 二维数组，模拟大厦所有房间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Room[][] rooms;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 盖楼通过构造方法盖楼</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Hotel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//一共有几层，每层的房间类型是什么，每个房间的编号是什么</span><br>        <span class="hljs-comment">//一层为单人间、二层为标准间、三层为总统套房</span><br>        <span class="hljs-comment">/*房间编号的规律</span><br><span class="hljs-comment">        * 1楼：101 102 103...</span><br><span class="hljs-comment">        * 2楼：201 202 203...</span><br><span class="hljs-comment">        * 3楼：301 302 302...*/</span><br><br>        rooms = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Room</span>[<span class="hljs-number">3</span>][<span class="hljs-number">10</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rooms.length ; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span> ; j &lt; rooms[i].length; j++ )&#123;<br>               <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span>)&#123;<br>                   rooms[i][j] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Room</span>((i+<span class="hljs-number">1</span>)*<span class="hljs-number">100</span>+j+<span class="hljs-number">1</span>,<span class="hljs-string">&quot;单人间&quot;</span>,<span class="hljs-literal">true</span>);<br>               &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>)&#123;<br>                   rooms[i][j] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Room</span>((i+<span class="hljs-number">1</span>)*<span class="hljs-number">100</span>+j+<span class="hljs-number">1</span>,<span class="hljs-string">&quot;标准间&quot;</span>,<span class="hljs-literal">true</span>);<br>               &#125;<span class="hljs-keyword">else</span>&#123;<br>                   rooms[i][j] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Room</span>((i+<span class="hljs-number">1</span>)*<span class="hljs-number">100</span>+j+<span class="hljs-number">1</span>,<span class="hljs-string">&quot;总统套房&quot;</span>,<span class="hljs-literal">true</span>);<br>               &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rooms.length ; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; rooms[i].length; j++) &#123;<br>                <span class="hljs-type">Room</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> rooms[i][j];<br>                System.out.print(room.toString() + <span class="hljs-string">&quot; | &quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 订房方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> roomNo 调用此方法是需要传递一个房间的编号过来。这个房间编号是前台输入过来的。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">order</span><span class="hljs-params">(<span class="hljs-type">int</span> roomNo)</span>&#123;<br>        <span class="hljs-comment">//订房最主要的是将房间对象的status改为false。</span><br>        <span class="hljs-comment">//Room对象的status修改为false</span><br>        <span class="hljs-type">Room</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> rooms[(roomNo / <span class="hljs-number">100</span>) - <span class="hljs-number">1</span>][(roomNo % <span class="hljs-number">100</span>) - <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//修改为占用</span><br>        room.setStatus(<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> roomNo)</span>&#123;<br>        <span class="hljs-type">Room</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> rooms[(roomNo / <span class="hljs-number">100</span>) - <span class="hljs-number">1</span>][(roomNo % <span class="hljs-number">100</span>) - <span class="hljs-number">1</span>];<br>        room.setStatus(<span class="hljs-literal">true</span>);<br>        System.out.println(roomNo + <span class="hljs-string">&quot;已退房！&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Room类：</strong> 房间信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company;<br><br><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 房间编号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> no;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 房间类型：标准间 单人间 总统套房</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String type;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 房间状态：</span><br><span class="hljs-comment">     * true:表示空闲，可以预定。</span><br><span class="hljs-comment">     * false：表示占用，不能预定</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> status;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Room</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Room</span><span class="hljs-params">(<span class="hljs-type">int</span> no, String type, <span class="hljs-type">boolean</span> status)</span> &#123;<br>        <span class="hljs-built_in">this</span>.no = no;<br>        <span class="hljs-built_in">this</span>.type = type;<br>        <span class="hljs-built_in">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> no;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNo</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;<br>        <span class="hljs-built_in">this</span>.no = no;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> type;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setType</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-built_in">this</span>.type = type;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isStatus</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStatus</span><span class="hljs-params">(<span class="hljs-type">boolean</span> status)</span> &#123;<br>        <span class="hljs-built_in">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * equals方法重写</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 房间号是否相等</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == obj) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span> || !(obj <span class="hljs-keyword">instanceof</span> Room)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">Room</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> (Room) obj;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getNo() == room.getNo();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(no, type, status);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * toString方法重写</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 输出房间信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;房间号为&quot;</span> + no +<br>                <span class="hljs-string">&quot;, 类型为&#x27;&quot;</span> + type + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, 状态为&quot;</span> + (status?<span class="hljs-string">&quot;空闲&quot;</span>:<span class="hljs-string">&quot;占用&quot;</span>) ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>运行截图：</strong><br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/af77d94c86097fae244b3a57644bb0c5-1741868481336-108.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h1 id="九、异常处理"><a href="#九、异常处理" class="headerlink" title="九、异常处理"></a>九、异常处理</h1><h2 id="1、异常的基本概念"><a href="#1、异常的基本概念" class="headerlink" title="1、异常的基本概念"></a>1、异常的基本概念</h2><h3 id="1、什么是异常-java提供异常处理机制有什么用"><a href="#1、什么是异常-java提供异常处理机制有什么用" class="headerlink" title="1、什么是异常, java提供异常处理机制有什么用?"></a><strong>1、什么是异常, java提供<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86&spm=1001.2101.3001.7020">异常处理</a>机制有什么用?</strong></h3><p><strong>异常就是程序执行过程中的不正确情况。</strong></p>
<blockquote>
<p>以下程序执行过程中发生了不正常的情况,而这种不正常的情况叫做:<strong>异常</strong><br>java语言是很完善的语言,提供了异常的处理方式,以下程序执行过程中出现了不正常情况，<br>java把该异常信息打印输出到控制台，供程序员参考。程序员看到异常信息之后，可以对<br>程序进行修改，让程序更加的健壮。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionTest01</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> c=a/b;<br>System. out.println(a + <span class="hljs-string">&quot;/”+ b + &quot;</span>=<span class="hljs-string">&quot;+ c);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<p><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/a299b2905ca02903abc8bfdcecbb032e-1741868481336-109.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>观察到异常信息之后,对程序进行修改，更加健壮</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionText</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>            <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>            <span class="hljs-type">int</span>  b=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;除数不能为0&quot;</span>);<br>                <span class="hljs-keyword">return</span>; <br>            &#125;<br>            <span class="hljs-type">int</span> c= a/b;<br>            System. out.println(a + <span class="hljs-string">&quot;/&quot;</span>+ b + <span class="hljs-string">&quot;=&quot;</span> + c);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>2、上述程序出现了异常信息：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ArithmeticException: / by zero<br>	at ExceptionText.main(ExceptionText.java:<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure>

<p>这个信息被我们称为：<strong>异常信息</strong>。这个信息是<strong>JVM打印的</strong></p>
<h3 id="2、java中异常以类和对象形式存在"><a href="#2、java中异常以类和对象形式存在" class="headerlink" title="2、java中异常以类和对象形式存在"></a>2、java中异常以类和对象形式存在</h3><p><strong>1、异常在Java中以类的形式存在，每一个异常类都可以创建异常对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionText</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>            <br>            <span class="hljs-comment">//java.lang.NumberFormatException: 数字格式化异常</span><br>            <span class="hljs-type">NumberFormatException</span> <span class="hljs-variable">nfe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberFormatException</span>(<span class="hljs-string">&quot;数字格式化异常&quot;</span>);<br>            System.out.println(nfe);<br><br>            <span class="hljs-type">NullPointerException</span> <span class="hljs-variable">npe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;空指针异常发生了&quot;</span>);<br>            <span class="hljs-comment">// java.lang.NullPointerException:空指针异常发生了</span><br>            System.out.println(npe);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ba02a7638518d037b5204e404ef440fa-1741868481336-110.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><strong>2、异常对应的现实是怎样的？</strong></p>
<blockquote>
<p><strong>火灾（异常类）</strong>：<br>2008年8月8日，小明家着火了（异常对象）<br>2008年8月9日，小刚家着火了（异常对象）<br>2008年9月8日，小红家着火了（异常对象）</p>
</blockquote>
<p><strong>类是模板，对象是实际存在的个体</strong></p>
<h2 id="2、异常的继承结构（UML图）"><a href="#2、异常的继承结构（UML图）" class="headerlink" title="2、异常的继承结构（UML图）"></a>2、异常的继承结构（UML图）</h2><p><strong>1、Object下有Throwable（可抛出的）</strong></p>
<blockquote>
<p><strong>不管是错误还是异常都是可以抛出的。</strong></p>
</blockquote>
<p><strong>2、Throwable下有两个分支：Error（不可处理的，直接退出JVM）和Exception（可处理的）</strong></p>
<blockquote>
<p><strong>所有的错误只要发生，Java程序只有一个结果，那就是终止程序的执行。退出JVM，错误是不能处理的。</strong></p>
</blockquote>
<p><strong>3、Exception下有两个分支</strong>：</p>
<ul>
<li><strong>Exception的直接子类（Exceptionsubclass）</strong>：编译时异常（要求程序员在编写程序阶段必须预先对这些异常进行处理，如果不处理编译器报错，因此得名编译时异常）</li>
<li><strong>RuntimeException：</strong> 运行时异常。（在编写程序阶段程序员可以预先处理，也可以不管）<br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/41b4af85fb656ddc42aec7e617ae7172-1741868481336-111.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></li>
</ul>
<h2 id="3、编译时异常和运行时异常区别"><a href="#3、编译时异常和运行时异常区别" class="headerlink" title="3、编译时异常和运行时异常区别"></a>3、编译时异常和运行时异常区别</h2><p><strong>1、编译时异常因为什么而得名</strong></p>
<p>编译时异常和运行时异常，都发生在<strong>运行阶段</strong>。编译阶段异常是不会发生的。<strong>编译时异常因为什么而得名？</strong></p>
<blockquote>
<p>因为编译时异常必须在编译（编写）阶段预先处理，如果不处理编译器报错，因此得名。<br>所有异常都是运行阶段发生的。因为只有程序运行阶段才可以new对象。<br>因为异常的发生都是new异常对象。</p>
</blockquote>
<p><strong>2、编译时异常和运行时异常区别</strong></p>
<ul>
<li><strong>编译时异常一般发生的概率比较高。<br>对于一些发生概率较高的异常，需要在运行之前对其进行预处理。</strong></li>
<li><strong>运行时异常一般发生的概率比较低。</strong></li>
</ul>
<p>假设java中没有对异常进行划分，没有分为：编译时异常和运行时异常，所有的异常都需要在编写程序阶段对其进行预处理，将会是怎样的效果呢？</p>
<blockquote>
<p>如果代码是这样的话，程序肯定是绝对安全的。但是程序员编写程序太累，代码到处都是处理异常的代码</p>
</blockquote>
<p><strong>3、编译时异常还有其他名字</strong></p>
<ul>
<li>受控异常 （CheckException）</li>
<li>受检异常</li>
</ul>
<p><strong>4、运行时异常还有其他名字</strong></p>
<ul>
<li>未受检异常（UnCheckException）</li>
<li>非受控异常</li>
</ul>
<p><strong>5、所有异常都发生在运行阶段的</strong></p>
<h2 id="4、Java两种异常处理的方式及原理"><a href="#4、Java两种异常处理的方式及原理" class="headerlink" title="4、Java两种异常处理的方式及原理"></a>4、Java两种异常处理的方式及原理</h2><h3 id="1、异常上抛"><a href="#1、异常上抛" class="headerlink" title="1、异常上抛"></a>1、异常上抛</h3><p><strong>在方法声明的位置上，使用<code>throws</code>关键字，抛给上一级</strong></p>
<blockquote>
<p>谁调用我，我就抛给谁，抛给上一级。</p>
</blockquote>
<h3 id="2、异常捕捉"><a href="#2、异常捕捉" class="headerlink" title="2、异常捕捉"></a>2、异常捕捉</h3><p><strong>使用<code>try..catch语句</code>进行异常的捕捉</strong></p>
<blockquote>
<p>这件事发生了，谁也不知，因为我给抓住了。</p>
</blockquote>
<p><strong>举例：</strong></p>
<p>我是某集团的一个销售员，因为我的失误，导致公司损失了1000块钱。”损失1000块”这可以看做一个异常发生了。我有两种处理方式。</p>
<ul>
<li>第一种方式：我把这件事告诉我的领导。【<strong>异常上抛</strong>】</li>
<li>第二种方式：我把自己的掏腰包把这个钱补上。【<strong>异常的捕捉</strong>】</li>
</ul>
<p>同样的异常发生之后，如果选择上抛，抛给了调用者，调用者需要对这个异常继续处理，那么调用者处理这个异常<strong>同样有两种处理方式</strong>。</p>
<p><strong>注意：</strong></p>
<p>Java中异常发生之后如果一直上抛，最终抛给了main方法，main方法继续向上抛，<strong>抛给了调用者JVM</strong>，JVM知道这个异常的发生，只有只有一个结果。终止java程序的执行。</p>
<p><strong>1、运行时异常编写程序时可以不处理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionTest01</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-type">int</span> c=a/b;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		程序执行到此处发生了ArithmeticException异常</span><br><span class="hljs-comment">		底层new一个ArithmeticException异常对象</span><br><span class="hljs-comment">		然后抛出了，由于是main方法调用了c=a/b</span><br><span class="hljs-comment">		所以这个异常ArithmeticException抛给main方法</span><br><span class="hljs-comment">		main方法没有处理，将这个异常自动抛给JVM</span><br><span class="hljs-comment">		JVM最终终止程序的执行</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		ArithmeticException 继承 RuntimeException，属于运行时异常。</span><br><span class="hljs-comment">		在编写程序阶段不需要对这种异常进行预先的处理。</span><br><span class="hljs-comment">		</span><br><span class="hljs-comment">		*/</span><br>		System. out.println(a + <span class="hljs-string">&quot;/”+ b + &quot;</span>=<span class="hljs-string">&quot;+ c);</span><br><span class="hljs-string"></span><br><span class="hljs-string">		//这里的HelloWorld没有输出，没有执行。</span><br><span class="hljs-string">		System.out.println(&quot;</span>Hello World!<span class="hljs-string">&quot;);//</span><br><span class="hljs-string">	&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<p><strong>2、方法声明上使用throws</strong></p>
<p>以下代码报错的原因是什么？</p>
<blockquote>
<p>因为doSome()方法声明位置上使用了：throws ClassNotFoundException<br>而ClassNotFoundException是编译时异常。必须编写代码时处理，没有处理编译器报错。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionText1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//main方法中调用doSome()方法</span><br>        <span class="hljs-comment">//因为doSome()方法声明位置上有：throws ClassNotFoundException</span><br>        <span class="hljs-comment">//我们在调用doSome()方法的时候必须对这种异常进行预先的处理。</span><br>        <span class="hljs-comment">//如果不处理,编译器就报错</span><br>        <span class="hljs-comment">//报错信息： 未报告的异常错误java.lang.ClassNotFoundException</span><br>        doSome();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * doSome方法在方法声明的位置上使用了：throws ClassNotFoundException</span><br><span class="hljs-comment">     * 这个代码表示doSome（）方法在执行过程中，有可能会出现ClassNotFoundException异常。</span><br><span class="hljs-comment">     * 叫做类没找到异常。这个异常直接父类是： Exception，所以ClassNotFoundException属于编译异常。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ClassNotFoundException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSome</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;<br>        System.out.println(<span class="hljs-string">&quot;doSome!!!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/f67d24cc2ebcf6c98e39b370f2bd4eef-1741868481336-112.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><strong>3、异常处理的具体方式</strong></p>
<p><strong>第一种处理方式：在方法声明的位置上继续使用：throws，来完成异常的继续上抛。抛给调用者</strong><br>上抛类似于推卸责任。（继续把异常传递给调用者）<br><strong>这种处理异常的态度：上报</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionText1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        doSome();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSome</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;<br>        System.out.println(<span class="hljs-string">&quot;doSome!!!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>第二种方式：<code>try ... catch</code>进行异常捕捉</strong><br>捕捉等于把异常拦下了，异常真正的解决了。（调用者不知道的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionText1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//尝试</span><br>        	doSome();<br>        &#125;<span class="hljs-keyword">catch</span> (ClassNotFoundException e)&#123;<br>        <span class="hljs-comment">//catch是捕捉异常之后走的分支</span><br>			e.printStackTrace;<br>		&#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSome</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;<br>        System.out.println(<span class="hljs-string">&quot;doSome!!!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>一般不建议在main方法上使用throws，因为这个异常如果真正发生了，一定会抛给JVM。JVM只有终止。一般采用<code>try...catch</code>进行捕捉。</strong></p>
<p><strong>4、异常捕捉和上报的联合使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionText2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main begin &quot;</span>);<br>        m1();<br>        System.out.println(<span class="hljs-string">&quot;main over&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;m1 begin&quot;</span>);<br>        m2();<br>        System.out.println(<span class="hljs-string">&quot;m1 over&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;m2 begin&quot;</span>);<br>        m3();<br>        System.out.println(<span class="hljs-string">&quot;m3 over&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//调用SUN jdk中某个类的构造方法</span><br>        <span class="hljs-comment">//这个类是IO流的</span><br>        <span class="hljs-comment">//创建一个输入流对象，该流指向一个文件。</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;C:\\Users\\Administrator\\Desktop\\Java自学\\学习.txt&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/67569c37bceafb9ceefedd0820a888e6-1741868481336-113.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><strong>编译报错的原因：</strong></p>
<ul>
<li>第一：这里调用了一个构造方法：<code>FileInputStream（String name）</code></li>
<li>第二：这个构造方法的声明位置上有：throws FileNotFoundException</li>
<li>第三：通过类的继承结构看到：FileNotFoundException父类是IOException，IOException的父类是Exception。</li>
</ul>
<p><strong>最终得知，FileNotFoundException是编译时异常。编译时异常要求程序员编写阶段必须对它进行处理，不处理编译器就报错</strong></p>
<p>进行异常处理后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionText2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main begin &quot;</span>);<br>        m1();<br>        System.out.println(<span class="hljs-string">&quot;main over&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;m1 begin&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            m2();<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        <span class="hljs-comment">//这个分支中可以使用e引用，e引用保存的内存地址是new出来异常对象的内存地址</span><br>        <span class="hljs-comment">//catch是捕捉异常之后走的分支</span><br>            System.out.println(<span class="hljs-string">&quot;文件不存在，可能路径错误，也可能文件被删除了！&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;m1 over&quot;</span>);<br>    &#125;<br><br>   <span class="hljs-comment">//也可以    throws Exception</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        System.out.println(<span class="hljs-string">&quot;m2 begin&quot;</span>);<br>        <span class="hljs-comment">//编译器报错的原因是：m3()方法声明位置上有：throws FileNotFoundException</span><br>        <span class="hljs-comment">//我们这里调用m3()没有对异常进行预处理，所以编译报错</span><br>        m3();<br>        System.out.println(<span class="hljs-string">&quot;m3 over&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-comment">//调用SUN jdk中某个类的构造方法</span><br>        <span class="hljs-comment">//这个类是IO流的</span><br>        <span class="hljs-comment">//创建一个输入流对象，该流指向一个文件。</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;C:\\Users\\Administrator\\Desktop\\Java自学\\学习.txt&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上抛异常也可以 <code>throws Exception</code></p>
<p><strong>注意：只要异常没有捕捉，采用上报的方式，此方法的后续代码不会执行。<br>另外需要注意，try语句块中的某一行出现异常，该行后面的代码不会执行。</strong></p>
<p><strong>5、上报和捕捉怎么选择？</strong></p>
<ul>
<li><strong>如果希望调用者来处理，选择throws上报。</strong></li>
<li><strong>其他情况可以使用捕捉的方式</strong></li>
</ul>
<h2 id="5、try…catch语句"><a href="#5、try…catch语句" class="headerlink" title="5、try…catch语句"></a>5、try…catch语句</h2><p><strong>1、catch后面的小括号的类型可以是具体的异常类型，也可以是该异常类的父类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionText2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;C:\\Users\\Administrator\\Desktop\\Java自学\\学习.txt&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;以上出现异常，这里的代码无法执行！&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(FileNotFoundException e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;文件不存在！&quot;</span>);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/45e016c77f8a2550759c5712560e2bd5-1741868481336-114.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><strong>也可以写为多态：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>	<span class="hljs-comment">//创建输入流</span><br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;C:\\Users\\Administrator\\Desktop\\Java自学\\学习.txt&quot;</span>);<br>&#125;<span class="hljs-keyword">catch</span>(IOException e)&#123; <span class="hljs-comment">//多态：IOException e = new FileNotFoundException();</span><br>    System.out.println(<span class="hljs-string">&quot;文件不存在！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>          <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;C:\\Users\\Administrator\\Desktop\\Java自学\\学习.txt&quot;</span>);<br>      &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123; <span class="hljs-comment">//多态：Exception e = new FileNotFoundException();</span><br>          System.out.println(<span class="hljs-string">&quot;文件不存在！&quot;</span>);<br>      &#125;<br></code></pre></td></tr></table></figure>

<p><strong>2、catch可以写多个</strong></p>
<p>建议catch的时候，精确的一个一个处理。这样有利于程序的调试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionText2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//创建输入流</span><br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;C:\\Users\\Administrator\\Desktop\\Java自学\\学习.txt&quot;</span>);<br>            <span class="hljs-comment">//读文件</span><br>            fis.read();<br>        &#125;<span class="hljs-keyword">catch</span>(FileNotFoundException e)&#123; <span class="hljs-comment">//所有异常都走这个分支</span><br>            System.out.println(<span class="hljs-string">&quot;文件不存在！&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;读文件报错了！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>3、catch后面异常中可以加 | 号（JDK8新特性，7不支持）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionText2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//创建输入流</span><br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;C:\\Users\\Administrator\\Desktop\\Java自学\\学习.txt&quot;</span>);<br><br>            System.out.println(<span class="hljs-number">100</span>/<span class="hljs-number">0</span>);<span class="hljs-comment">//这个异常是运行时异常，编写程序时可以处理，也可以不处理</span><br><br>        &#125;<span class="hljs-keyword">catch</span>(FileNotFoundException | ArithmeticException | NullPointerException e)&#123; <span class="hljs-comment">//所有异常都走这个分支</span><br>            System.out.println(<span class="hljs-string">&quot;文件不存在？数字异常？空指针异常？都有可能！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>4、catch写多个的时候，从上到下，必须遵守从小到大</strong></p>
<h2 id="6、获取异常对象的方法：getMessage和printStackTrace"><a href="#6、获取异常对象的方法：getMessage和printStackTrace" class="headerlink" title="6、获取异常对象的方法：getMessage和printStackTrace()"></a>6、获取异常对象的方法：getMessage和printStackTrace()</h2><h3 id="1、getMessage"><a href="#1、getMessage" class="headerlink" title="1、getMessage"></a>1、getMessage</h3><p><strong>获取异常简单的描述信息。</strong></p>
<p>语法格式：<code>String msg = exception.getMessage();</code></p>
<h3 id="2、printStackTrace"><a href="#2、printStackTrace" class="headerlink" title="2、printStackTrace()"></a>2、printStackTrace()</h3><p><strong>打印异常追踪的堆栈信息，比较适合于程序的调试阶段</strong></p>
<p>语法格式：<code>exception.printStackTrace();</code></p>
<h3 id="3、两个方法的实例"><a href="#3、两个方法的实例" class="headerlink" title="3、两个方法的实例"></a>3、两个方法的实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionText3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//这里只是为了测试getMessage()方法和printStackTrace()方法</span><br>        <span class="hljs-comment">//这里只是new了异常对象，但是没有将异常对象抛出。JVM会认为这是一个普通的java对象。</span><br>        <span class="hljs-type">NullPointerException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;空指针异常Exception &quot;</span>);<br><br>        <span class="hljs-comment">//获取异常简单描述信息：这个信息实际上就是构造方法上面String参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> e.getMessage();<span class="hljs-comment">//空指针异常Exception</span><br>        System.out.println(msg);<br><br>        <span class="hljs-comment">//打印异常堆栈信息</span><br>        <span class="hljs-comment">//java后台打印异常堆栈追踪信息的时候，采用了异步线程的方式打印的。</span><br>        e.printStackTrace();<br><br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/56d3cae2401bbd3a0fec893130806055-1741868481336-115.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h3 id="4、查看异常的追踪信息"><a href="#4、查看异常的追踪信息" class="headerlink" title="4、查看异常的追踪信息"></a><strong>4、查看异常的追踪信息</strong></h3><p>我们应该怎么看，可以快速的调试程序呢？</p>
<blockquote>
<p>异常信息追踪信息，从上往下一行一行看。<br>但是需要注意的是：SUN写的代码就不用看了。主要问题是出现在自己编写的代码上。</p>
</blockquote>
<p>即从运行结果中的<code>at ExceptionText3.m3(ExceptionText3.java:27)</code>这一行看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionText3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            m1();<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            <span class="hljs-comment">//打印异常堆栈追踪信息</span><br>            <span class="hljs-comment">//在实际开发中建议使用这个。养成好习惯</span><br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-comment">//这里程序不耽误执行，很健壮</span><br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        m2();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        m3();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;C:\\Users\\Administrator\\Desktop\\学习a.txt&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/f89a4c862d6970cb43bbf5a4922da4a4-1741868481336-116.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><strong>因为27行出现了问题导致23行<br>23行出问题导致19行<br>19行出问题导致7行<br>应该先查看27行的的代码。27行是错误的根源，从根上看问题</strong></p>
<p><strong>防止误导再加一条！！！！：</strong></p>
<p><strong>尽量不要使用e.printStackTrace(),而是使用log打印。</strong></p>
<p>反例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-comment">// do what you want  </span><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>  e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-comment">// do what you want  </span><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>  log.info(<span class="hljs-string">&quot;你的程序有异常啦,&#123;&#125;&quot;</span>,e);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>理由：</p>
<ul>
<li><p>printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。</p>
</li>
<li><p>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了,即内存满了，那么，用户的请求就卡住啦~</p>
</li>
</ul>
<h2 id="7、finally关键字"><a href="#7、finally关键字" class="headerlink" title="7、finally关键字"></a>7、finally关键字</h2><p><strong>关于try…catch中的finally子句</strong></p>
<h3 id="1、在finally子句中的代码是最后执行的，并且是一定会执行的，即使try语句块中的代码出现了异常。"><a href="#1、在finally子句中的代码是最后执行的，并且是一定会执行的，即使try语句块中的代码出现了异常。" class="headerlink" title="1、在finally子句中的代码是最后执行的，并且是一定会执行的，即使try语句块中的代码出现了异常。"></a>1、在finally子句中的代码是最后执行的，并且是一定会执行的，即使try语句块中的代码出现了异常。</h3><ul>
<li>finally子句必须和try一起出现，不能单独编写。</li>
</ul>
<h3 id="2、finally语句通常使用在哪些情况下呢？"><a href="#2、finally语句通常使用在哪些情况下呢？" class="headerlink" title="2、finally语句通常使用在哪些情况下呢？"></a>2、finally语句通常使用在哪些情况下呢？</h3><blockquote>
<p><strong>通常在finally语句块中完成资源的释放&#x2F;关闭</strong><br><strong>因为finally中的代码比较有保障</strong><br><strong>即使try语句块中的代码出现异常，finally中的代码也会正常执行</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionText3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//声明位置放到try外面，这样在finally中才能用</span><br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//创建输入流对象</span><br>            fis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;C:\\Users\\Administrator\\Desktop\\学习.txt&quot;</span>);<br>            <span class="hljs-comment">//开始读文件...</span><br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">//这里一定会出现空指针异常！</span><br>            s.toString();<br>            System.out.println(<span class="hljs-string">&quot;hello world!&quot;</span>);<br><br>            <span class="hljs-comment">//流使用完需要关闭，因为流是占用资源的</span><br>            <span class="hljs-comment">//即使以上程序出现异常，流也必须要关闭</span><br>            <span class="hljs-comment">//放在这里有可能流关不了</span><br>            <span class="hljs-comment">//fis.close();</span><br>        &#125;<span class="hljs-keyword">catch</span>(FileNotFoundException e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">catch</span>(IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">catch</span>(NullPointerException e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;hello 浩克&quot;</span>);<br>            <span class="hljs-comment">//流的关闭放在这里比较保险</span><br>            <span class="hljs-comment">//finally中的代码是一定会执行的</span><br>            <span class="hljs-comment">//即使try中出现了异常！</span><br>            <span class="hljs-keyword">if</span>(fis != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//避免空指针异常</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//close方法有异常采用捕捉的方式</span><br>                    fis.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;hello kitty!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>fis.close</code>未被注释前：</strong><br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9788dcef9a38f7e79d6892ab750d74b1-1741868481336-117.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><strong>修改后：</strong><br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/a716e37161d251f9a050e69d81f4a88f-1741868481336-118.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h3 id="3、try和finally，也可以没有catch"><a href="#3、try和finally，也可以没有catch" class="headerlink" title="3、try和finally，也可以没有catch"></a>3、try和finally，也可以没有catch</h3><ul>
<li><strong>try不能单独使用。</strong></li>
<li><strong>try 可以和finally联合使用。</strong></li>
</ul>
<p><strong>以下代码的执行顺序：</strong></p>
<blockquote>
<p>先执行try…<br>再执行finally<br>最后执行return（return语句只要执行方法必然结束）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionText4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;try...&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//finally中的语句会执行。能执行到。</span><br>            System.out.println(<span class="hljs-string">&quot;finally...&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//这里不能写语句，因为这个代码是无法执行到的。</span><br>        <span class="hljs-comment">//System.out.println(&quot;Helloword&quot;);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>运行结果：</strong><br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4c2c99eb5fe42b508afc3b1e60d0432b-1741868481336-119.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h3 id="4、退出JVM，finally语句不执行"><a href="#4、退出JVM，finally语句不执行" class="headerlink" title="4、退出JVM，finally语句不执行"></a>4、退出<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=JVM&spm=1001.2101.3001.7020">JVM</a>，finally语句不执行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionText5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;try..&quot;</span>);<br>            <span class="hljs-comment">//退出JVM</span><br>            System.exit(<span class="hljs-number">0</span>);<span class="hljs-comment">//退出JVM之后，finally语句中的代码就不执行了！</span><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;finally..&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>运行结果：</strong><br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/f154e592b428ea8489264d99cf95c37f-1741868481336-120.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h3 id="5、关于finally的一道面试题"><a href="#5、关于finally的一道面试题" class="headerlink" title="5、关于finally的一道面试题"></a>5、关于finally的一道面试题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionText5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> m();<br>        System.out.println(result);<span class="hljs-comment">//结果为100</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">m</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//这行代码出现在int i = 100的下面，所以最终结果必须是返回100</span><br>        <span class="hljs-comment">//return语句还必须保证是最后执行的。一但执行，整个方法结束。</span><br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            i++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后的结果为 <strong><code>100</code>：</strong><br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/afb809465734bb03c854e3a22455a12b-1741868481336-121.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><strong>解释：</strong> Java语法中有这样一条规则：</p>
<ul>
<li><strong>方法体中的代码必须遵循自上而下顺序依次逐行执行</strong>（亘古不变的语法！）</li>
</ul>
<p>Java中还有一条语法规则：</p>
<ul>
<li><strong>return语句一但执行，整个方法必须结束</strong>（亘古不变的语法！）</li>
</ul>
<p>反编译之后的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">m</span><span class="hljs-params">()</span>&#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>	i++;<br>	<span class="hljs-keyword">return</span> j;<br>	Exception exception;<br>	exception;<br>	i++;<br>	<span class="hljs-keyword">throws</span> exception;	<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="8、final、finalize和finally的区别"><a href="#8、final、finalize和finally的区别" class="headerlink" title="8、final、finalize和finally的区别"></a>8、final、finalize和finally的区别</h2><h3 id="1、final"><a href="#1、final" class="headerlink" title="1、final"></a>1、final</h3><p><strong>final是一个关键字。表示最终的，不可变的。</strong></p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs axapta">   <span class="hljs-comment">//final修饰的变量无法重新赋值。</span><br><br>   <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> i = <span class="hljs-number">100</span>;<br>   <span class="hljs-comment">//i = 200； 不能变</span><br><br>   <span class="hljs-comment">//final修饰的类无法继承</span><br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br> 	<span class="hljs-comment">//常量</span><br> 	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">double</span> MATH_PI = <span class="hljs-number">3.1415926</span>;<br>&#125;<br><br>   <span class="hljs-comment">//final修饰的方法无法覆盖</span><br><br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br> 	<span class="hljs-keyword">public</span>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> doSome()&#123;<br><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2、finalize"><a href="#2、finalize" class="headerlink" title="2、finalize"></a>2、finalize</h3><p><strong>finalize()方法JVM的GC垃圾回收器负责调用</strong></p>
<p>当一个java对象即将被<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6&spm=1001.2101.3001.7020">垃圾回收</a>器回收的时候，垃圾回收器负责调用finalize()方法。<strong>如果希望在对象销毁时机执行一段代码的话，这段代码要写到finalize()方法中</strong>（留遗嘱）</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl">  - <span class="hljs-function"><span class="hljs-title">finalize</span>()是<span class="hljs-variable"><span class="hljs-class">Object</span></span>类中的一个方法。作为方法名出现</span><br><span class="hljs-function">  - 所以<span class="hljs-variable">finalize</span>是一个标识符。</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-variable"><span class="hljs-class">Object</span></span> <span class="hljs-variable">obj</span>;</span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure>

<h2 id="3、finally"><a href="#3、finally" class="headerlink" title="3、finally"></a>3、finally</h2><p><strong>finally是一个关键字，和try联合使用，使用在异常处理机制中。</strong></p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">   - 在<span class="hljs-keyword">finally</span>语句块中的代码是一定会执行的。<br><br><span class="hljs-keyword">try</span> &#123;<br>	<br>&#125;<span class="hljs-keyword">catch</span>&#123;<br>	System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;finally...&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="9、如何自定义异常及手动抛出异常"><a href="#9、如何自定义异常及手动抛出异常" class="headerlink" title="9、如何自定义异常及手动抛出异常"></a>9、如何自定义异常及手动抛出异常</h2><h3 id="1、自定义异常的方法"><a href="#1、自定义异常的方法" class="headerlink" title="1、自定义异常的方法"></a>1、自定义异常的方法</h3><p>需要两步：</p>
<ul>
<li>第一步：<strong>编写一个类继承Exception或者RunTimeException</strong></li>
<li>第二步：<strong>提供两个构造方法，一个无参数的，一个带有String参数的。</strong></li>
</ul>
<p><strong>MyException类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&#123;<span class="hljs-comment">//编译时异常</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>main类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalsText</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//创建异常对象（只new了异常对象，并没有手动抛出）</span><br>        <span class="hljs-type">MyException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyException</span>(<span class="hljs-string">&quot;用户名不能为空&quot;</span>);<br><br>        <span class="hljs-comment">//打印异常堆栈信息</span><br>        e.printStackTrace();<br><br>        <span class="hljs-comment">//获取异常简单描述信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> e.getMessage();<br>        System.out.println(msg);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>运行结果：</strong><br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6f276cefc1a6294c9f10e65b97eb092a-1741868481336-122.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h3 id="2、使用的时候需要手动抛出异常（throw）"><a href="#2、使用的时候需要手动抛出异常（throw）" class="headerlink" title="2、使用的时候需要手动抛出异常（throw）"></a>2、使用的时候需要手动抛出异常（throw）</h3><p>语法格式：<code>throw + 异常类的对象</code></p>
<h2 id="10、异常与方法覆盖"><a href="#10、异常与方法覆盖" class="headerlink" title="10、异常与方法覆盖"></a>10、异常与方法覆盖</h2><p><strong>在方法覆盖时</strong>，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%87%8D%E5%86%99&spm=1001.2101.3001.7020">重写</a>之后的方法<strong>不能</strong>比重写之前的方法<strong>抛出更多（更宽泛）的异常</strong>，可以<strong>更少（更小）的异常</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSome</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doOther</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>    <span class="hljs-comment">//编译错误</span><br>    <span class="hljs-comment">/*public void doSome throws Exception() &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-comment">//编译正常</span><br>    <span class="hljs-comment">/* public void doOther()&#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-comment">//编译正常</span><br><span class="hljs-comment">/*    public void doOther() throws Exception &#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-comment">//编译正常</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doOther</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="十、反射机制"><a href="#十、反射机制" class="headerlink" title="十、反射机制"></a>十、反射机制</h1><h2 id="1、Java之反射机制详解"><a href="#1、Java之反射机制详解" class="headerlink" title="1、Java之反射机制详解"></a>1、Java之反射机制详解</h2><h3 id="1、反射机制"><a href="#1、反射机制" class="headerlink" title="1、反射机制"></a>1、反射机制</h3><p>反射机制在<code>java.lang.reflect.*</code>包下<br>反射机制相关的重要的类有</p>
<ul>
<li><code>java.lang.Class</code>：代表字节码文件，代表一个类型，代表整个类。</li>
<li><code>java.lang.reflect.Method</code>：代表字节码中的方法字节码。代表类中的方法。</li>
<li><code>java.lang.reflect.Constructor</code>：代表字节码中的构造方法字节码。代表类中的构造方法</li>
<li><code>java.lang.reflect.Field</code>：代表字节码中的属性字节码。代表类中的成员变量（局部变量）</li>
</ul>
<h3 id="2、反射机制有什么用"><a href="#2、反射机制有什么用" class="headerlink" title="2、反射机制有什么用"></a>2、反射机制有什么用</h3><p>通过java语言中的反射机制可以<strong>操作字节码文件</strong>。有点类似于黑客（可以读和修改字节码文件。）通过反射机制可以操作代码片段。（class文件）让<strong>程序更加灵活</strong>。</p>
<h3 id="3、获取Class文件的三种方式"><a href="#3、获取Class文件的三种方式" class="headerlink" title="3、获取Class文件的三种方式"></a>3、获取Class文件的三种方式</h3><h4 id="1、Class-forName"><a href="#1、Class-forName" class="headerlink" title="1、Class.forName()"></a>1、Class.forName()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectTest01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-comment">/*        Class.forName()</span><br><span class="hljs-comment">                1、静态方法</span><br><span class="hljs-comment">                2、方法的参数是一个字符串</span><br><span class="hljs-comment">                3、字符串需要的是一个完整的类名</span><br><span class="hljs-comment">                4、完整类名必须带有包名。java.lang包也不能省略*/</span><br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<span class="hljs-comment">//c1代表的是String.class文件，或者说c1代表String类型</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.util.Date&quot;</span>);<span class="hljs-comment">//c2代表Date类型</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.Integer&quot;</span>);<span class="hljs-comment">//c3代表Integer类型</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.System&quot;</span>);<span class="hljs-comment">//c4代表System类型&#125;</span><br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<p>如果只希望一个类的静态代码块执行，<strong>其他代码一律不执行</strong>，可以使用：<code>Class.forName(&quot;完整类名&quot;);</code><br>这个方法的执行会导致类加载，<strong>类加载时，静态代码块执行</strong>。</p>
<h4 id="2、getClass-方法"><a href="#2、getClass-方法" class="headerlink" title="2、getClass()方法"></a>2、getClass()方法</h4><p>java中任何一个对象都有一个方法：<code>getClass()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectTest01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-comment">/*        Class.forName()</span><br><span class="hljs-comment">                1、静态方法</span><br><span class="hljs-comment">                2、方法的参数是一个字符串</span><br><span class="hljs-comment">                3、字符串需要的是一个完整的类名</span><br><span class="hljs-comment">                4、完整类名必须带有包名。java.lang包也不能省略*/</span><br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>         c1 = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<span class="hljs-comment">//c1代表的是String.class文件，或者说c1代表String类型</span><br>		&#125;<span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>    <span class="hljs-type">Class</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> s.getClass();<span class="hljs-comment">//x代表String.class字节码文件，x代表String类型</span><br>        System.out.println(c1 == x); <span class="hljs-comment">//true(==判断的是对象的内存地址)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1f49980318540bf66ab4929bb866aaa6-1741868481337-123.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9bec0d038bdaac3005175a5e2888c363-1741868481337-124.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="3、java类型的-class属性"><a href="#3、java类型的-class属性" class="headerlink" title="3、java类型的.class属性"></a>3、java类型的.class属性</h4><p>java语言中任何一种类型，包括基本数据类型，它都有.class属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> String.class; <span class="hljs-comment">//z代表String类型</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Date.class;<span class="hljs-comment">//k代表Date类型</span><br></code></pre></td></tr></table></figure>

<h3 id="4、通过反射实例化对象"><a href="#4、通过反射实例化对象" class="headerlink" title="4、通过反射实例化对象"></a>4、通过反射实例化对象</h3><p>获取.class能干什么？</p>
<p>通过Class的<code>newInstance()</code>方法来<strong>实例化对象</strong>。<br>注意：<code>newInstance()</code>方法内部实际上调用了<strong>无参数的构造方法</strong>，必须保证无参数构造存在才可以。</p>
<p><strong>使用反射机制的方式来创建对象：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;无参数的构造方法&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-number">12345</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectTest02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//通过反射机制，获取Class，通过Class；来实例化对象</span><br>            <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;User&quot;</span>);<span class="hljs-comment">//c代表User类型</span><br><br>            <span class="hljs-comment">//newInstance() 这个方法会调用User这个类的无参数构造方法，完成对象的创建。</span><br>            <span class="hljs-comment">//重点是:newInstance()调用的是无参构造，必须保证无参构造是存在的！！！！</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> c.newInstance();<br><br>            System.out.println(obj);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/13c89595a7098bfcfd349ef6281fb1ac-1741868481337-125.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h3 id="5、通过读属性文件实例化对象"><a href="#5、通过读属性文件实例化对象" class="headerlink" title="5、通过读属性文件实例化对象"></a>5、通过读属性文件实例化对象</h3><p>验证反射机制的灵活性。java代码只写一遍，在不改变java源代码的基础之上，可以做到不同对象的实例化。非常之灵活（符合OCP开闭原则：对扩展开放，对修改关闭）</p>
<p><strong>classinfo.properties文件：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">className = User<br><span class="hljs-number">1</span><br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectTest03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//通过IO流读取classinfo.properties文件</span><br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;classinfo.properties&quot;</span>);<br>        <span class="hljs-comment">//创建属性类对象Map</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">pro</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-comment">//加载</span><br>        pro.load(reader);<br>        <span class="hljs-comment">//关闭流</span><br>        reader.close();<br><br>        <span class="hljs-comment">//通过key获取value</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">calssName</span> <span class="hljs-operator">=</span> pro.getProperty(<span class="hljs-string">&quot;className&quot;</span>);<br>        System.out.println(calssName);<br><br>        <span class="hljs-comment">//通过反射机制实例化对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(calssName);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> c.newInstance();<br>        System.out.println(obj);<br>    &#125;<br>&#125;<br><span class="hljs-number">123456789101112131415161718192021222324</span><br></code></pre></td></tr></table></figure>

<h3 id="6、资源绑定器"><a href="#6、资源绑定器" class="headerlink" title="6、资源绑定器"></a>6、资源绑定器</h3><p><code>java.util</code>包下提供了一个资源绑定器，便于获取配置文件中的内容。使用以下方法的时候，属性配置文件<code>×××.properties</code>必须放到类路径下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ResourceBundle;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest04</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//资源绑定器，只能绑定×××.properties文件。并且这个文件必须在src/类路径下。文件扩展名必须是properties</span><br>        <span class="hljs-comment">//并且在写路径的时候，路径的后面扩展名不能写</span><br>        <span class="hljs-type">ResourceBundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> ResourceBundle.getBundle(<span class="hljs-string">&quot;classinfo3&quot;</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> bundle.getString(<span class="hljs-string">&quot;className&quot;</span>);<br>        System.out.println(className);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="7、类加载器"><a href="#7、类加载器" class="headerlink" title="7、类加载器"></a>7、类加载器</h3><h4 id="1、什么是加载器"><a href="#1、什么是加载器" class="headerlink" title="1、什么是加载器"></a>1、什么是加载器</h4><p>专门负责加载类的命令&#x2F;工具。<code>ClassLoader</code></p>
<h4 id="2、JDK中自带的类加载器"><a href="#2、JDK中自带的类加载器" class="headerlink" title="2、JDK中自带的类加载器"></a>2、JDK中自带的类加载器</h4><ul>
<li><strong>启动类加载器</strong>：<code>rt.jar</code></li>
<li><strong>扩展类加载器</strong>：<code>ext/*.jar</code></li>
<li><strong>应用类加载器</strong>：<code>classpath</code></li>
</ul>
<p>假如执行以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>代码在开始执行以前，会将所<strong>需要类全部加载到JVM</strong>当中。</p>
<p>通过<strong>类加载器加载</strong>，看到以上代码<strong>类加载器</strong>会找<code>string. class</code>文件，找到就加载，那么是怎么进行加载的呢?</p>
<ul>
<li>首先通过 <strong>“启动类加载器”</strong> 加载。<br>注意:启动类加载器专门加载: <code>C: \Program Files\Java\jdk1.8.0_ 101\jre\lib\rt.jar</code><br><strong>rt. jar中都是JDK最核心的类库</strong>。</li>
<li>如果通过 <strong>“启动类加载器”加载不到</strong> 的时候,会通过 <strong>“扩展类加载器”</strong> 加载。<br>注意:扩展类加载器专门加载: <code>C: \Program Files\Java\jdk1.8.0_ 101\jre\lib\ext\*.jar</code></li>
<li>如果 <strong>“扩展类加载器”</strong> 没有加载到，那么会通过 <strong>“应用类加载器”</strong> 加载。<br>注意：应用类加载器专门加载：<code>classpath</code>中的类。</li>
</ul>
<h4 id="3、双亲委派机制"><a href="#3、双亲委派机制" class="headerlink" title="3、双亲委派机制"></a>3、双亲委派机制</h4><p>java中为了保证类加载的安全，使用了<strong>双亲委派机制</strong>。<strong>优先从启动类加载器</strong>中加载，这个称为 <strong>“父”</strong>，”父”无法加载到，再从<strong>扩展类加载器</strong>中加载，这个称为**“母”<strong>。双亲委派。*<em>如果都加载不到*</em>，才会考虑从**应用类加载器</strong>中加载。直到加载到为止。</p>
<h3 id="8、Field"><a href="#8、Field" class="headerlink" title="8、Field"></a>8、Field</h3><h4 id="1、获取Field"><a href="#1、获取Field" class="headerlink" title="1、获取Field"></a>1、获取Field</h4><p>反射属性Field，Field翻译为字段，其实就是属性&#x2F;成员。<br>4个Field，分别采用了不同的访问控制权限修饰符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">//4个Field，分别采用了不同的访问控制权限修饰符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> no;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">boolean</span> sex;<br>&#125;<br><span class="hljs-number">1234567</span><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Modifier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectTest05</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//获取整个类</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">studentClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;Student&quot;</span>);<br>        <span class="hljs-comment">//获取类中所有的public修饰的Field</span><br>        Field[] fields = studentClass.getFields();<br>        System.out.println(fields.length);<br>        <span class="hljs-comment">//取出这个Field的名</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> fields[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fieldName</span> <span class="hljs-operator">=</span> f.getName();<br>        System.out.println(fieldName);<br><br>        <span class="hljs-comment">//获取所有的Field</span><br>        Field[] fields1 = studentClass.getDeclaredFields();<br>        System.out.println(fields1.length);<br><br>        <span class="hljs-keyword">for</span> (Field field : fields1) &#123;<br>            <span class="hljs-comment">//获取属性的修饰符</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> field.getModifiers();<span class="hljs-comment">//返回的修饰符是一个数字，每个数字都是修饰符的代号</span><br>            System.out.println(i);<br>            <span class="hljs-comment">//将代号转化为字符串</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">modifiersString</span> <span class="hljs-operator">=</span> Modifier.toString(i);<br>            System.out.println(modifiersString);<br>            <span class="hljs-comment">//获取属性的类型</span><br>            <span class="hljs-type">Class</span> <span class="hljs-variable">fieldType</span> <span class="hljs-operator">=</span> field.getType();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">fName</span> <span class="hljs-operator">=</span> fieldType.getName();<br>            System.out.println(fName);<br>            <span class="hljs-comment">//获取属性的名字</span><br>            System.out.println(field.getName());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/cd93096d74eda4beb824b28e4d6c0e57-1741868481337-126.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="2、反编译Field"><a href="#2、反编译Field" class="headerlink" title="2、反编译Field"></a>2、反编译Field</h4><p>通过反射机制，反编译一个类的属性Field</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Modifier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectTese06</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//创建这个是为为了拼接字符串。</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">studentClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;Student&quot;</span>);<br><br>        s.append(Modifier.toString(studentClass.getModifiers())+ <span class="hljs-string">&quot; class &quot;</span>+ studentClass.getSimpleName() + <span class="hljs-string">&quot;Student&#123;\n&quot;</span>);<br><br>        Field[] fields = studentClass.getDeclaredFields();<br><br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            s.append(<span class="hljs-string">&quot;\t&quot;</span>);<br>            s.append(Modifier.toString(field.getModifiers()));<br>            s.append(<span class="hljs-string">&quot; &quot;</span>);<br>            s.append(field.getType().getSimpleName());<br>            s.append(<span class="hljs-string">&quot; &quot;</span>);<br>            s.append(field.getName());<br>            s.append(<span class="hljs-string">&quot;;\n&quot;</span>);<br>        &#125;<br>        s.append(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>        System.out.println(s);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>运行结果：</strong><br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/8f3513c481fa78c94ac677ba0ffe9a03-1741868481337-127.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="3、通过反射机制访问java对象属性（重点掌握）"><a href="#3、通过反射机制访问java对象属性（重点掌握）" class="headerlink" title="3、通过反射机制访问java对象属性（重点掌握）"></a>3、通过反射机制访问java对象属性（重点掌握）</h4><p>给属性赋值set<br>获取属性的值get</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectTest07</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//不使用反射机制怎样访问一个对象的属性</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><br>        <span class="hljs-comment">//给属性赋值</span><br>        s.no = <span class="hljs-number">1111</span>;<br><br>        <span class="hljs-comment">//读属性值</span><br>        System.out.println(s.no);<br><br>        <span class="hljs-comment">//使用反射机制，访问一个对象的属性</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">studentClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;Student&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> studentClass.newInstance();<span class="hljs-comment">//obj就是Student对象。（底层调用无参数构造方法）</span><br><br>        <span class="hljs-comment">//获取no属性(根据属性的名称来获取Field)</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">noField</span> <span class="hljs-operator">=</span> studentClass.getDeclaredField(<span class="hljs-string">&quot;no&quot;</span>);<br><br>        <span class="hljs-comment">//给obj对象（student对象）的no属性赋值</span><br>        <span class="hljs-comment">/*虽然使用了反射机制，但是三要素还是缺一不可：</span><br><span class="hljs-comment">            要素1：obj对象。</span><br><span class="hljs-comment">            要素2：no属性；</span><br><span class="hljs-comment">            要素3:2222值。</span><br><span class="hljs-comment">         注意：反射机制让代码复杂了，但是为了一个“灵活”，这也是值得的。</span><br><span class="hljs-comment">        */</span><br>        noField.set(obj,<span class="hljs-number">2222</span>);<span class="hljs-comment">//给obj对象的no属性赋值2222</span><br><br>        <span class="hljs-comment">//读取属性的值</span><br>        <span class="hljs-comment">//两个要素：获取obj对象的no属性的值。</span><br>        System.out.println(noField.get(obj));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/a6fd428345e5319643b9bbff88f1431a-1741868481337-128.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h3 id="9、Method"><a href="#9、Method" class="headerlink" title="9、Method"></a>9、Method</h3><h4 id="1、可变长度参数"><a href="#1、可变长度参数" class="headerlink" title="1、可变长度参数"></a>1、可变长度参数</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">int<span class="hljs-params">...</span> args<span class="hljs-string">`这就是可变长度参数</span><br><span class="hljs-string">语法是：`</span>类型<span class="hljs-params">...</span> (注意：一定是<span class="hljs-number">3</span>个点)<br></code></pre></td></tr></table></figure>

<ul>
<li>1、可变长度参数要求的<strong>参数个数</strong>是：<strong>0~N个</strong>。</li>
<li>2、可变长度参数在参数列表中必须在<strong>最后一个位置</strong>上，而且可变长度参数<strong>只能有一个。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArgsTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        m();<br>        m(<span class="hljs-number">10</span>);<br>        m(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">(<span class="hljs-type">int</span>... args)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;m方法执行了！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c161dce245d0791f4d5d5cffacf3cae3-1741868481337-129.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h4 id="2、反射Method"><a href="#2、反射Method" class="headerlink" title="2、反射Method"></a>2、反射Method</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;<br>	<span class="hljs-keyword">private</span> String name;	<br>	String address;<br>	<span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> sno;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name, String address, <span class="hljs-type">int</span> sno)</span> &#123;<br>		<span class="hljs-built_in">super</span>();<br>		<span class="hljs-built_in">this</span>.id = id;<br>		<span class="hljs-built_in">this</span>.name = name;<br>		<span class="hljs-built_in">this</span>.address = address;<br>		<span class="hljs-built_in">this</span>.sno = sno;<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;study...&quot;</span>);<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(<span class="hljs-type">int</span> a,String b)</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;eat...&quot;</span>);<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Modifier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>		<span class="hljs-comment">// 获取类</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">usrClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.lzj.reflect.pojo.User&quot;</span>);<br><br>        <span class="hljs-comment">// 获取所有的Method（包括私有）</span><br>        Method[] methods = usrClass.getDeclaredMethods();<br>        <br>        <span class="hljs-comment">// 遍历Method</span><br>        <span class="hljs-keyword">for</span>(Method method : methods)&#123;<br>            <span class="hljs-comment">// 获取修饰符列表</span><br>            System.out.println(Modifier.toString(method.getModifiers()));<br>            <span class="hljs-comment">// 获取方法的返回值类型</span><br>            System.out.println(method.getReturnType().getSimpleName());<br>            <span class="hljs-comment">// 获取方法名</span><br>            System.out.println(method.getName());<br>            <span class="hljs-comment">// 方法的修饰符列表（一个方法的参数可能会有多个）</span><br>            Class[] parameterTypes = method.getParameterTypes();<br>            <span class="hljs-keyword">for</span>(Class parameterType : parameterTypes)&#123;<br>                System.out.println(parameterType.getSimpleName());<br>            &#125;<br>        &#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3、反编译Method"><a href="#3、反编译Method" class="headerlink" title="3、反编译Method"></a>3、反编译Method</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Modifier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>		<span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">userClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.lzj.reflect.pojo.User&quot;</span>);<br>        s.append(Modifier.toString(userClass.getModifiers()) + <span class="hljs-string">&quot; class &quot;</span>+userClass.getSimpleName()+<span class="hljs-string">&quot; &#123;\n&quot;</span>);<br><br>        Method[] methods = userClass.getDeclaredMethods();<br>        <span class="hljs-keyword">for</span>(Method method : methods)&#123;<br>        	<br>            s.append(<span class="hljs-string">&quot;\t&quot;</span>);<br>            s.append(Modifier.toString(method.getModifiers()));<br>            s.append(<span class="hljs-string">&quot; &quot;</span>);<br>            s.append(method.getReturnType().getSimpleName());<br>            s.append(<span class="hljs-string">&quot; &quot;</span>);<br>            s.append(method.getName());<br>            s.append(<span class="hljs-string">&quot;(&quot;</span>);<br>            <br>            Class[] parameterTypes = method.getParameterTypes();<br>            <span class="hljs-keyword">for</span>(Class parameterType : parameterTypes)&#123;<br>                s.append(parameterType.getSimpleName());<br>                s.append(<span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(parameterTypes.length &gt; <span class="hljs-number">0</span>) &#123;<br>            	s.deleteCharAt(s.length() - <span class="hljs-number">1</span>);<br>            &#125;<br>            <br>            s.append(<span class="hljs-string">&quot;)&#123;&#125;\n&quot;</span>);<br>        &#125;<br>        s.append(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>        System.out.println(s);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4、通过反射机制调用方法（重点掌握）"><a href="#4、通过反射机制调用方法（重点掌握）" class="headerlink" title="4、通过反射机制调用方法（重点掌握）"></a>4、通过反射机制调用方法（重点掌握）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.lgz.Test&quot;</span>);<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;run&quot;</span>);<br>            method.invoke(clazz.newInstance());<br><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">methodPrivate</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;eat&quot;</span>);<br>            methodPrivate.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//调private方法</span><br>            methodPrivate.invoke(clazz.newInstance());<br><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">methodStatic</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;work&quot;</span>);<br>            methodStatic.invoke(<span class="hljs-literal">null</span>);<br><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method1</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;speak&quot;</span>, <span class="hljs-type">int</span>.class, String.class);<br>            method1.invoke(clazz.newInstance(), <span class="hljs-number">22</span>, <span class="hljs-string">&quot;小明&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;work() 方法被调用...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;eat() 方法被调用...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;run() 方法被调用...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speak</span><span class="hljs-params">(<span class="hljs-type">int</span> age, String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;speak() 方法被调用.... age = &quot;</span> + age + <span class="hljs-string">&quot; name= &quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="10、Constructor"><a href="#10、Constructor" class="headerlink" title="10、Constructor"></a>10、Constructor</h3><p>1）<strong>得到某个类所有的构造方法</strong></p>
<p><code>Constructor[] constructors = Class.forName(&quot;java.lang.String&quot;).getConstructors();</code><br>2）<strong>得到某一个构造方法</strong></p>
<p><code>Constructor constructor1 = String.class.getConstructor(StringBuffer.class);</code><br>实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> String.class.getConstructor(StringBuffer.class);<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> (String) constructor.newInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;abc&quot;</span>));<br>System.out.println(str.charAt(<span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure>

<p><strong>打印结果：c</strong></p>
<h3 id="11、获取父类和父接口"><a href="#11、获取父类和父接口" class="headerlink" title="11、获取父类和父接口"></a>11、获取父类和父接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectTest08</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//String举例</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">stringClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br><br>        <span class="hljs-comment">//获取String的父类</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> stringClass.getSuperclass();<br>        System.out.println(superClass);<br><br>        <span class="hljs-comment">//获取String类实现的所有接口（一个类可以实现多个接口）</span><br>        Class[] interfaces = stringClass.getInterfaces();<br>        <span class="hljs-keyword">for</span> (Class anInterface : interfaces) &#123;<br>            System.out.println(anInterface);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/99609d9e53061862049aa57ce3f8c8a3-1741868481337-130.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h1 id="十一、注解"><a href="#十一、注解" class="headerlink" title="十一、注解"></a>十一、注解</h1><h2 id="1、java之注解详解"><a href="#1、java之注解详解" class="headerlink" title="1、java之注解详解"></a>1、java之注解详解</h2><h3 id="1、注解如何定义？怎么用？"><a href="#1、注解如何定义？怎么用？" class="headerlink" title="1、注解如何定义？怎么用？"></a>1、注解如何定义？怎么用？</h3><p><strong>注解，或者说叫做注释类型，英文单词是：Annotation</strong></p>
<p>注解Annotation是一种<strong>引用数据类型</strong>。编译之后也是生成<code>XXX.class</code>文件。</p>
<p><strong>自定义注解：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[修饰符列表] <span class="hljs-meta">@interface</span> 注解类型名&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注解怎么使用，用在什么地方？</p>
<ul>
<li>第一：注解使用时的语法格式是：<code>@ 注解类型名</code></li>
<li>第二：注解还可以出现在<strong>类上、属性上、方法上、变量上</strong>等…注解还可以出现在<strong>注解类型</strong>上。</li>
</ul>
<p>JDK内置了哪些注释？<br><code>java.lang</code>包下的注释类型：</p>
<ul>
<li>掌握：<code>Deprecated</code>，用<code>@Deprecated</code>注释的<strong>程序元素</strong>。不鼓励程序员使用这样的元素，通常是因为它很危险或存在更好的选择。</li>
<li>掌握：<code>Override</code>，表示一个方法声明打算<strong>重写超类的另一个方法</strong>声明。</li>
<li>不用掌握：SuppressWarnings，指示应该在注释元素（以及包含在该注释元素中的所有程序元素）中取消显示指定的编译器警告。</li>
</ul>
<h3 id="2、自定义注解"><a href="#2、自定义注解" class="headerlink" title="2、自定义注解"></a>2、自定义注解</h3><p>注解以@开头<br>在idea中new一个自定义注解<br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/f47fa769ad4cf015e20dc4ec82923aec-1741868481337-131.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>自定义注解的依法格式：</p>
<p><strong>【修饰符列表】 @interface 注解名称{…}</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> FirstAnnotation &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用注解：@注解名称 如：@Override</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MyAnnotation</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2、Override注解"><a href="#2、Override注解" class="headerlink" title="2、Override注解"></a>2、Override注解</h3><p>关于JDK lang包下的Override注解<br>源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>@Override</code>只能注解方法。</li>
<li><code>@Override</code>这个注解是给编译器参考的，和运行阶段没有关系</li>
<li>凡是java中的方法带有这个注解的，编译器都会进行编译检查，如果这个方法不是重写父类的方法，编译器报错。</li>
</ul>
<h3 id="4、元注解"><a href="#4、元注解" class="headerlink" title="4、元注解"></a>4、元注解</h3><h4 id="1、什么是元注解"><a href="#1、什么是元注解" class="headerlink" title="1、什么是元注解?"></a>1、什么是元注解?</h4><p>用来标注”注解类型的”注解”。称为元注解</p>
<h4 id="2、常见的元注解有哪些"><a href="#2、常见的元注解有哪些" class="headerlink" title="2、常见的元注解有哪些?"></a>2、常见的元注解有哪些?</h4><ul>
<li>Target</li>
<li>Retention</li>
</ul>
<h4 id="3、关于Target注解"><a href="#3、关于Target注解" class="headerlink" title="3、关于Target注解:"></a>3、关于Target注解:</h4><p>这是一个<strong>元注解</strong>,用来标注”注解类型”的注解”<br>这个Target注解用来标注”被标注的注解”可以出现在哪些位置上<br><code>@Target (ElementType .METHOD)</code>:表示w被标注的注解只能出现在方法上.</p>
<h4 id="4、关于Retention注解"><a href="#4、关于Retention注解" class="headerlink" title="4、关于Retention注解:"></a>4、关于Retention注解:</h4><p>这是一个<strong>元注解</strong>,用来标注”注解类型”的”注解”<br>这个<code>Retention</code>注解用来标注”被标注的注解”最终<strong>保存在哪里</strong>。</p>
<p><code>@Retention(RetentionPolicy .SOURCE)</code>:表示该注解只被保留在<strong>java源文件</strong>中。<code>@Retention(RetentionPolicy.CLASS)</code>:表示该注解被保存在<strong>class文件</strong>中<br><code>@Retention(RetentionPolicy.RUNTIME)</code>:表示该注解被保存在class文件中，并且可以</p>
<h3 id="5、Deprecated注解"><a href="#5、Deprecated注解" class="headerlink" title="5、Deprecated注解"></a>5、Deprecated注解</h3><p>表示已过时的。</p>
<p><strong>源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Deprecated &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6、使用反射获取注解信息"><a href="#6、使用反射获取注解信息" class="headerlink" title="6、使用反射获取注解信息"></a>6、使用反射获取注解信息</h3><p>需求：创建一个自定义注解，在Person类上及Person的方法上使用注解，在测试类中通过反射获取标注在Person类和方法上的注解信息。</p>
<p><strong>注意：自定义注解必须用@Retention（RetentionPolicy.RUNTIME）标注，这样自定义注解才能被反射机制读取到。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> PersonInfo &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-number">12345</span><br><span class="hljs-meta">@PersonInfo(age=20,name=&quot;张三&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    <span class="hljs-meta">@PersonInfo(age=30,name=&quot;李四&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;run方法执行了.....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectPersonInfo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;<br>        <span class="hljs-comment">//获取Person类对象</span><br>        Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;cn.itcast.annotation.Person&quot;</span>);<br><br>        <span class="hljs-comment">//获取标注在Person类上的@PersonInfo注解信息</span><br>        <span class="hljs-keyword">if</span>(aClass.isAnnotationPresent(PersonInfo.class))&#123;    <span class="hljs-comment">//判断Person类上是否有@PersonInfo注解标注</span><br>            <span class="hljs-comment">//获取注解对象</span><br>            <span class="hljs-type">PersonInfo</span> <span class="hljs-variable">personInfo</span> <span class="hljs-operator">=</span> aClass.getAnnotation(PersonInfo.class);<br><br>            <span class="hljs-comment">//打印标注在Person类上的@PersonInfo注解信息</span><br>            System.out.println(personInfo.age());<br>            System.out.println(personInfo.name());<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;----------------------------&quot;</span>);<br>        <br>        <span class="hljs-comment">//获取标注在Person类的方法上的@Person注解信息</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">eat</span> <span class="hljs-operator">=</span> aClass.getDeclaredMethod(<span class="hljs-string">&quot;eat&quot;</span>);   <span class="hljs-comment">//获取Person类的eat方法对象</span><br>        <span class="hljs-keyword">if</span>(eat.isAnnotationPresent(PersonInfo.class))&#123;        <span class="hljs-comment">//判断Person类的eat方法上是否有@PersonInfo注解标注</span><br>            <span class="hljs-comment">//获取标注在eat方法上的注解对象</span><br>            <span class="hljs-type">PersonInfo</span> <span class="hljs-variable">personInfo</span> <span class="hljs-operator">=</span> eat.getAnnotation(PersonInfo.class);<br><br>            <span class="hljs-comment">//打印标注在Person类中的eat()方法上的注解信息</span><br>            System.out.println(personInfo.name());<br>            System.out.println(personInfo.age());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试结果：<br><img src="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5dfd822728adedf08667b0186ba60e82-1741868481337-132.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/JAVA/" class="category-chain-item">JAVA</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/JAVA/" class="print-no-link">#JAVA</a>
      
        <a href="/tags/%E5%9F%BA%E7%A1%80/" class="print-no-link">#基础</a>
      
        <a href="/tags/%E7%AC%94%E8%AE%B0/" class="print-no-link">#笔记</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>JAVA基础知识笔记</div>
      <div>https://aotomata.me/2020/04/19/Java基础知识/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>吕书科</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年4月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/04/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/" title="多线程并发基础">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">多线程并发基础</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
